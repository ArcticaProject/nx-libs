/*
 * Mesa 3-D graphics library
 * Version:  6.2
 *
 * Copyright (C) 1999-2004  Brian Paul   All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
 * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
 
 /**
 * \file arbprogram.syn
 * ARB_fragment/vertex_program syntax
 * \author Michal Krol
 */
 
.syntax program;

/*
   This value must be incremented every time emit code values or structure of the production
   array changes. This value is placed at the beginning of the production array. The loader
   compares the value with its REVISION value. If they do not match, the loader is not up
   to date.
*/
.emtcode REVISION                                   0x09

/* program type */
.emtcode FRAGMENT_PROGRAM                           0x01
.emtcode VERTEX_PROGRAM                             0x02

/* program section */
.emtcode OPTION                                     0x01
.emtcode INSTRUCTION                                0x02
.emtcode DECLARATION                                0x03
.emtcode END                                        0x04

/* GL_ARB_fragment_program option */
.emtcode ARB_PRECISION_HINT_FASTEST                 0x00
.emtcode ARB_PRECISION_HINT_NICEST                  0x01
.emtcode ARB_FOG_EXP                                0x02
.emtcode ARB_FOG_EXP2                               0x03
.emtcode ARB_FOG_LINEAR                             0x04

/* GL_ARB_vertex_program option */
.emtcode ARB_POSITION_INVARIANT                     0x05

/* GL_ARB_fragment_program_shadow option */
.emtcode ARB_FRAGMENT_PROGRAM_SHADOW                0x06

/* GL_ARB_draw_buffers option */
.emtcode ARB_DRAW_BUFFERS                           0x07

/* GL_ARB_fragment_program instruction class */
.emtcode OP_ALU_INST                                0x00
.emtcode OP_TEX_INST                                0x01

/* GL_ARB_vertex_program instruction class */
/*       OP_ALU_INST */

/* GL_ARB_fragment_program instruction type */
.emtcode OP_ALU_VECTOR                               0x00
.emtcode OP_ALU_SCALAR                               0x01
.emtcode OP_ALU_BINSC                                0x02
.emtcode OP_ALU_BIN                                  0x03
.emtcode OP_ALU_TRI                                  0x04
.emtcode OP_ALU_SWZ                                  0x05
.emtcode OP_TEX_SAMPLE                               0x06
.emtcode OP_TEX_KIL                                  0x07

/* GL_ARB_vertex_program instruction type */
.emtcode OP_ALU_ARL                                  0x08
/*       OP_ALU_VECTOR */
/*       OP_ALU_SCALAR */
/*       OP_ALU_BINSC */
/*       OP_ALU_BIN */
/*       OP_ALU_TRI */
/*       OP_ALU_SWZ */

/* GL_ARB_fragment_program instruction code */
.emtcode OP_ABS                                     0x00
.emtcode OP_ABS_SAT                                 0x1B
.emtcode OP_FLR                                     0x09
.emtcode OP_FLR_SAT                                 0x26
.emtcode OP_FRC                                     0x0A
.emtcode OP_FRC_SAT                                 0x27
.emtcode OP_LIT                                     0x0C
.emtcode OP_LIT_SAT                                 0x2A
.emtcode OP_MOV                                     0x11
.emtcode OP_MOV_SAT                                 0x30
.emtcode OP_COS                                     0x1F
.emtcode OP_COS_SAT                                 0x20
.emtcode OP_EX2                                     0x07
.emtcode OP_EX2_SAT                                 0x25
.emtcode OP_LG2                                     0x0B
.emtcode OP_LG2_SAT                                 0x29
.emtcode OP_RCP                                     0x14
.emtcode OP_RCP_SAT                                 0x33
.emtcode OP_RSQ                                     0x15
.emtcode OP_RSQ_SAT                                 0x34
.emtcode OP_SIN                                     0x38
.emtcode OP_SIN_SAT                                 0x39
.emtcode OP_SCS                                     0x35
.emtcode OP_SCS_SAT                                 0x36
.emtcode OP_POW                                     0x13
.emtcode OP_POW_SAT                                 0x32
.emtcode OP_ADD                                     0x01
.emtcode OP_ADD_SAT                                 0x1C
.emtcode OP_DP3                                     0x03
.emtcode OP_DP3_SAT                                 0x21
.emtcode OP_DP4                                     0x04
.emtcode OP_DP4_SAT                                 0x22
.emtcode OP_DPH                                     0x05
.emtcode OP_DPH_SAT                                 0x23
.emtcode OP_DST                                     0x06
.emtcode OP_DST_SAT                                 0x24
.emtcode OP_MAX                                     0x0F
.emtcode OP_MAX_SAT                                 0x2E
.emtcode OP_MIN                                     0x10
.emtcode OP_MIN_SAT                                 0x2F
.emtcode OP_MUL                                     0x12
.emtcode OP_MUL_SAT                                 0x31
.emtcode OP_SGE                                     0x16
.emtcode OP_SGE_SAT                                 0x37
.emtcode OP_SLT                                     0x17
.emtcode OP_SLT_SAT                                 0x3A
.emtcode OP_SUB                                     0x18
.emtcode OP_SUB_SAT                                 0x3B
.emtcode OP_XPD                                     0x1A
.emtcode OP_XPD_SAT                                 0x43
.emtcode OP_CMP                                     0x1D
.emtcode OP_CMP_SAT                                 0x1E
.emtcode OP_LRP                                     0x2B
.emtcode OP_LRP_SAT                                 0x2C
.emtcode OP_MAD                                     0x0E
.emtcode OP_MAD_SAT                                 0x2D
.emtcode OP_SWZ                                     0x19
.emtcode OP_SWZ_SAT                                 0x3C
.emtcode OP_TEX                                     0x3D
.emtcode OP_TEX_SAT                                 0x3E
.emtcode OP_TXB                                     0x3F
.emtcode OP_TXB_SAT                                 0x40
.emtcode OP_TXP                                     0x41
.emtcode OP_TXP_SAT                                 0x42
.emtcode OP_KIL                                     0x28

/* GL_ARB_vertex_program instruction code */
.emtcode OP_ARL                                     0x02
/*       OP_ABS */
/*       OP_FLR */
/*       OP_FRC */
/*       OP_LIT */
/*       OP_MOV */
/*       OP_EX2 */
.emtcode OP_EXP                                     0x08
/*       OP_LG2 */
.emtcode OP_LOG                                     0x0D
/*       OP_RCP */
/*       OP_RSQ */
/*       OP_POW */
/*       OP_ADD */
/*       OP_DP3 */
/*       OP_DP4 */
/*       OP_DPH */
/*       OP_DST */
/*       OP_MAX */
/*       OP_MIN */
/*       OP_MUL */
/*       OP_SGE */
/*       OP_SLT */
/*       OP_SUB */
/*       OP_XPD */
/*       OP_MAD */
/*       OP_SWZ */

/* fragment attribute binding */
.emtcode FRAGMENT_ATTRIB_COLOR                      0x01
.emtcode FRAGMENT_ATTRIB_TEXCOORD                   0x02
.emtcode FRAGMENT_ATTRIB_FOGCOORD                   0x03
.emtcode FRAGMENT_ATTRIB_POSITION                   0x04

/* vertex attribute binding */
.emtcode VERTEX_ATTRIB_POSITION                     0x01
.emtcode VERTEX_ATTRIB_WEIGHT                       0x02
.emtcode VERTEX_ATTRIB_NORMAL                       0x03
.emtcode VERTEX_ATTRIB_COLOR                        0x04
.emtcode VERTEX_ATTRIB_FOGCOORD                     0x05
.emtcode VERTEX_ATTRIB_TEXCOORD                     0x06
.emtcode VERTEX_ATTRIB_MATRIXINDEX                  0x07
.emtcode VERTEX_ATTRIB_GENERIC                      0x08

/* fragment result binding */
.emtcode FRAGMENT_RESULT_COLOR                      0x01
.emtcode FRAGMENT_RESULT_DEPTH                      0x02

/* vertex result binding */
.emtcode VERTEX_RESULT_POSITION                     0x01
.emtcode VERTEX_RESULT_COLOR                        0x02
.emtcode VERTEX_RESULT_FOGCOORD                     0x03
.emtcode VERTEX_RESULT_POINTSIZE                    0x04
.emtcode VERTEX_RESULT_TEXCOORD                     0x05

/* texture target */
.emtcode TEXTARGET_1D                               0x01
.emtcode TEXTARGET_2D                               0x02
.emtcode TEXTARGET_3D                               0x03
.emtcode TEXTARGET_RECT                             0x04
.emtcode TEXTARGET_CUBE                             0x05
/* GL_ARB_fragment_program_shadow */
.emtcode TEXTARGET_SHADOW1D                         0x06
.emtcode TEXTARGET_SHADOW2D                         0x07
.emtcode TEXTARGET_SHADOWRECT                       0x08

/* face type */
.emtcode FACE_FRONT                                 0x00
.emtcode FACE_BACK                                  0x01

/* color type */
.emtcode COLOR_PRIMARY                              0x00
.emtcode COLOR_SECONDARY                            0x01

/* component */
.emtcode COMPONENT_X                                0x00
.emtcode COMPONENT_Y                                0x01
.emtcode COMPONENT_Z                                0x02
.emtcode COMPONENT_W                                0x03
.emtcode COMPONENT_0                                0x04
.emtcode COMPONENT_1                                0x05

/* array index type */
.emtcode ARRAY_INDEX_ABSOLUTE                       0x00
.emtcode ARRAY_INDEX_RELATIVE                       0x01

/* matrix name */
.emtcode MATRIX_MODELVIEW                           0x01
.emtcode MATRIX_PROJECTION                          0x02
.emtcode MATRIX_MVP                                 0x03
.emtcode MATRIX_TEXTURE                             0x04
.emtcode MATRIX_PALETTE                             0x05
.emtcode MATRIX_PROGRAM                             0x06

/* matrix modifier */
.emtcode MATRIX_MODIFIER_IDENTITY                   0x00
.emtcode MATRIX_MODIFIER_INVERSE                    0x01
.emtcode MATRIX_MODIFIER_TRANSPOSE                  0x02
.emtcode MATRIX_MODIFIER_INVTRANS                   0x03

/* constant type */
.emtcode CONSTANT_SCALAR                            0x01
.emtcode CONSTANT_VECTOR                            0x02

/* program param type */
.emtcode PROGRAM_PARAM_ENV                          0x01
.emtcode PROGRAM_PARAM_LOCAL                        0x02

/* register type */
.emtcode REGISTER_ATTRIB                            0x01
.emtcode REGISTER_PARAM                             0x02
.emtcode REGISTER_RESULT                            0x03
.emtcode REGISTER_ESTABLISHED_NAME                  0x04

/* param binding */
.emtcode PARAM_NULL                                 0x00
.emtcode PARAM_ARRAY_ELEMENT                        0x01
.emtcode PARAM_STATE_ELEMENT                        0x02
.emtcode PARAM_PROGRAM_ELEMENT                      0x03
.emtcode PARAM_PROGRAM_ELEMENTS                     0x04
.emtcode PARAM_CONSTANT                             0x05

/* param state property */
.emtcode STATE_MATERIAL                             0x01
.emtcode STATE_LIGHT                                0x02
.emtcode STATE_LIGHT_MODEL                          0x03
.emtcode STATE_LIGHT_PROD                           0x04
.emtcode STATE_FOG                                  0x05
.emtcode STATE_MATRIX_ROWS                          0x06
/* GL_ARB_fragment_program */
.emtcode STATE_TEX_ENV                              0x07
.emtcode STATE_DEPTH                                0x08
/* GL_ARB_vertex_program */
.emtcode STATE_TEX_GEN                              0x09
.emtcode STATE_CLIP_PLANE                           0x0A
.emtcode STATE_POINT                                0x0B

/* state material property */
.emtcode MATERIAL_AMBIENT                           0x01
.emtcode MATERIAL_DIFFUSE                           0x02
.emtcode MATERIAL_SPECULAR                          0x03
.emtcode MATERIAL_EMISSION                          0x04
.emtcode MATERIAL_SHININESS                         0x05

/* state light property */
.emtcode LIGHT_AMBIENT                              0x01
.emtcode LIGHT_DIFFUSE                              0x02
.emtcode LIGHT_SPECULAR                             0x03
.emtcode LIGHT_POSITION                             0x04
.emtcode LIGHT_ATTENUATION                          0x05
.emtcode LIGHT_HALF                                 0x06
.emtcode LIGHT_SPOT_DIRECTION                       0x07

/* state light model property */
.emtcode LIGHT_MODEL_AMBIENT                        0x01
.emtcode LIGHT_MODEL_SCENECOLOR                     0x02

/* state light product property */
.emtcode LIGHT_PROD_AMBIENT                         0x01
.emtcode LIGHT_PROD_DIFFUSE                         0x02
.emtcode LIGHT_PROD_SPECULAR                        0x03

/* state texture environment property */
.emtcode TEX_ENV_COLOR                              0x01

/* state texture generation coord property */
.emtcode TEX_GEN_EYE                                0x01
.emtcode TEX_GEN_OBJECT                             0x02

/* state fog property */
.emtcode FOG_COLOR                                  0x01
.emtcode FOG_PARAMS                                 0x02

/* state depth property */
.emtcode DEPTH_RANGE                                0x01

/* state point parameters property */
.emtcode POINT_SIZE                                 0x01
.emtcode POINT_ATTENUATION                          0x02

/* declaration */
.emtcode ATTRIB                                     0x01
.emtcode PARAM                                      0x02
.emtcode TEMP                                       0x03
.emtcode OUTPUT                                     0x04
.emtcode ALIAS                                      0x05
/* GL_ARB_vertex_program */
.emtcode ADDRESS                                    0x06

/* error messages */
.errtext UNKNOWN_PROGRAM_SIGNATURE                  "1001: '$e_signature$': unknown program signature"
.errtext MISSING_END_OR_INVALID_STATEMENT           "1002: '$e_statement$': invalid statement"
.errtext CODE_AFTER_END                             "1003: '$e_statement$': code after 'END' keyword"
.errtext INVALID_PROGRAM_OPTION                     "1004: '$e_identifier$': invalid program option"
.errtext EXT_SWIZ_COMP_EXPECTED                     "1005: extended swizzle component expected but '$e_token$' found"
.errtext TEX_TARGET_EXPECTED                        "1006: texture target expected but '$e_token$' found"
.errtext TEXTURE_EXPECTED                           "1007: 'texture' expected but '$e_identifier$' found"
.errtext SOURCE_REGISTER_EXPECTED                   "1008: source register expected but '$e_token$' found"
.errtext DESTINATION_REGISTER_EXPECTED              "1009: destination register expected but '$e_token$' found"
.errtext INVALID_ADDRESS_COMPONENT                  "1010: '$e_identifier$': invalid address component"
.errtext INVALID_ADDRESS_WRITEMASK                  "1011: '$e_identifier$': invalid address writemask"
.errtext INVALID_COMPONENT                          "1012: '$e_charordigit$': invalid component"
.errtext INVALID_SUFFIX                             "1013: '$e_identifier$': invalid suffix"
.errtext INVALID_WRITEMASK                          "1014: '$e_identifier$': invalid writemask"
.errtext FRAGMENT_EXPECTED                          "1015: 'fragment' expected but '$e_identifier$' found"
.errtext VERTEX_EXPECTED                            "1016: 'vertex' expected but '$e_identifier$' found"
.errtext INVALID_FRAGMENT_PROPERTY                  "1017: '$e_identifier$': invalid fragment property"
.errtext INVALID_VERTEX_PROPERTY                    "1018: '$e_identifier$': invalid vertex property"
.errtext INVALID_STATE_PROPERTY                     "1019: '$e_identifier$': invalid state property"
.errtext INVALID_MATERIAL_PROPERTY                  "1020: '$e_identifier$': invalid material property"
.errtext INVALID_LIGHT_PROPERTY                     "1021: '$e_identifier$': invalid light property"
.errtext INVALID_SPOT_PROPERTY                      "1022: '$e_identifier$': invalid spot property"
.errtext INVALID_LIGHTMODEL_PROPERTY                "1023: '$e_identifier$': invalid light model property"
.errtext INVALID_LIGHTPROD_PROPERTY                 "1024: '$e_identifier$': invalid light product property"
.errtext INVALID_TEXENV_PROPERTY                    "1025: '$e_identifier$': invalid texture environment property"
.errtext INVALID_TEXGEN_PROPERTY                    "1026: '$e_identifier$': invalid texture generating property"
.errtext INVALID_TEXGEN_COORD                       "1027: '$e_identifier$': invalid texture generating coord"
.errtext INVALID_FOG_PROPERTY                       "1028: '$e_identifier$': invalid fog property"
.errtext INVALID_DEPTH_PROPERTY                     "1029: '$e_identifier$': invalid depth property"
.errtext INVALID_CLIPPLANE_PROPERTY                 "1030: '$e_identifier$': invalid clip plane property"
.errtext INVALID_POINT_PROPERTY                     "1031: '$e_identifier$': invalid point property"
.errtext MATRIX_ROW_SELECTOR_OR_MODIFIER_EXPECTED   "1032: matrix row selector or modifier expected but '$e_token$' found"
.errtext INVALID_MATRIX_NAME                        "1033: '$e_identifier$': invalid matrix name"
.errtext INVALID_PROGRAM_PROPERTY                   "1034: '$e_identifier$': invalid program property"
.errtext RESULT_EXPECTED                            "1035: 'result' expected but '$e_token$' found"
.errtext INVALID_RESULT_PROPERTY                    "1036: '$e_identifier$': invalid result property"
.errtext INVALID_FACE_PROPERTY                      "1037: '$e_identifier$': invalid face property"
.errtext INVALID_COLOR_PROPERTY                     "1038: '$e_identifier$': invalid color property"
.errtext IDENTIFIER_EXPECTED                        "1039: identifier expected but '$e_token$' found"
.errtext RESERVED_KEYWORD                           "1040: use of reserved keyword as an identifier"
.errtext INTEGER_EXPECTED                           "1041: integer value expected but '$e_token$' found"
.errtext MISSING_SEMICOLON                          "1042: ';' expected but '$e_token$' found"
.errtext MISSING_COMMA                              "1043: ',' expected but '$e_token$' found"
.errtext MISSING_LBRACKET                           "1044: '[' expected but '$e_token$' found"
.errtext MISSING_RBRACKET                           "1045: ']' expected but '$e_token$' found"
.errtext MISSING_DOT                                "1046: '.' expected but '$e_token$' found"
.errtext MISSING_EQUAL                              "1047: '=' expected but '$e_token$' found"
.errtext MISSING_LBRACE                             "1048: '{' expected but '$e_token$' found"
.errtext MISSING_RBRACE                             "1049: '}' expected but '$e_token$' found"
.errtext MISSING_DOTDOT                             "1050: '..' expected but '$e_token$' found"
.errtext MISSING_FRACTION_OR_EXPONENT               "1051: missing fraction part or exponent"
.errtext MISSING_DOT_OR_EXPONENT                    "1052: missing '.' or exponent"
.errtext EXPONENT_VALUE_EXPECTED                    "1053: exponent value expected"
.errtext INTEGER_OUT_OF_RANGE                       "1054: integer value out of range"
.errtext OPERATION_NEEDS_DESTINATION_VARIABLE       "1055: operation needs destination variable"
.errtext OPERATION_NEEDS_SOURCE_VARIABLE            "1056: operation needs source variable"
.errtext ADDRESS_REGISTER_EXPECTED                  "1057: address register expected but '$e_token$' found"
.errtext ADDRESS_REGISTER_OR_INTEGER_EXPECTED       "1058: address register or integer literal expected but '$e_token$' found"

/* extension presence condition registers */

/* GL_ARB_vertex_blend */
/* GL_EXT_vertex_weighting */
.regbyte vertex_blend                               0x00

/* GL_ARB_matrix_palette */
.regbyte matrix_palette                             0x00

/* GL_ARB_point_parameters */
/* GL_EXT_point_parameters */
.regbyte point_parameters                           0x00

/* GL_EXT_secondary_color */
.regbyte secondary_color                            0x00

/* GL_EXT_fog_coord */
.regbyte fog_coord                                  0x00

/* GL_EXT_texture_rectangle */
/* GL_NV_texture_rectangle */
.regbyte texture_rectangle                          0x00

/* GL_ARB_fragment_program_shadow */
.regbyte fragment_program_shadow                    0x00

/* GL_ARB_draw_buffers */
.regbyte draw_buffers                               0x00

/* option presence condition registers */
/* they are all initially set to zero - when a particular OPTION is encountered, the appropriate */
/* register is set to 1 to indicate that the OPTION was specified. */

/* GL_ARB_fragment_program */
.regbyte ARB_precision_hint_fastest                 0x00
.regbyte ARB_precision_hint_nicest                  0x00
.regbyte ARB_fog_exp                                0x00
.regbyte ARB_fog_exp2                               0x00
.regbyte ARB_fog_linear                             0x00

/* GL_ARB_vertex_program */
.regbyte ARB_position_invariant                     0x00

/* GL_ARB_fragment_program_shadow */
.regbyte ARB_fragment_program_shadow                0x00

/* GL_ARB_draw_buffers */
.regbyte ARB_draw_buffers                           0x00

/* program target condition register */
/* this syntax script deals with two program targets - VERTEX_PROGRAM and FRAGMENT_PROGRAM. */
/* to distinguish between them we need a register that will store for us the current target. */
/* the client will typically set the register to apropriate value before parsing a particular */
/* program. the mapping between program targets and their values is listed below. */
/* */
/* program target               register value    */
/* ---------------------------------------------- */
/* FRAGMENT_PROGRAM             0x10              */
/* VERTEX_PROGRAM               0x20              */
/* */
/* the initial value of the register is 0 to catch potential errors with not setting the register */
/* with the proper value. */
.regbyte program_target                             0x00

/*
    <program>              ::= <optionSequence> <statementSequence> "END"
*/
program
    programs .error UNKNOWN_PROGRAM_SIGNATURE .emit REVISION;
programs
    .if (program_target == 0x10) frag_program_1_0 .emit FRAGMENT_PROGRAM .emit 0x01 .emit 0x00 .or
    .if (program_target == 0x20) vert_program_1_0 .emit VERTEX_PROGRAM .emit 0x01 .emit 0x00;
frag_program_1_0
    '!' .and '!' .and 'A' .and 'R' .and 'B' .and 'f' .and 'p' .and '1' .and '.' .and '0' .and
    optional_space .and fp_optionSequence .and fp_statementSequence .and
    "END" .error MISSING_END_OR_INVALID_STATEMENT .emit END .and optional_space .and
    '\0' .error CODE_AFTER_END;
vert_program_1_0
    '!' .and '!' .and 'A' .and 'R' .and 'B' .and 'v' .and 'p' .and '1' .and '.' .and '0' .and
    optional_space .and vp_optionSequence .and vp_statementSequence .and
    "END" .error MISSING_END_OR_INVALID_STATEMENT .emit END .and optional_space .and
    '\0' .error CODE_AFTER_END;

/*
    <optionSequence>       ::= <optionSequence> <option>
                             | ""
*/
fp_optionSequence
    .loop fp_option;
vp_optionSequence
    .loop vp_option;

/*
    <option>               ::= "OPTION" <identifier> ";"

NOTE: options ARB_precision_hint_nicest and ARB_precision_hint_fastest are exclusive. When one of
      these options is encountered, the other one is automatically disabled.
      the same applies to options ARB_fog_exp, ARB_fog_exp2 and ARB_fog_linear.
*/
fp_option
    "OPTION" .emit OPTION .and space .error IDENTIFIER_EXPECTED .and
    fp_optionString .error INVALID_PROGRAM_OPTION .and semicolon;
vp_option
    "OPTION" .emit OPTION .and space .error IDENTIFIER_EXPECTED .and
    vp_optionString .error INVALID_PROGRAM_OPTION .and semicolon;
fp_optionString
    .if (ARB_precision_hint_nicest == 0x00) "ARB_precision_hint_fastest"
        .emit ARB_PRECISION_HINT_FASTEST .load ARB_precision_hint_fastest 0x01 .or
    .if (ARB_precision_hint_fastest == 0x00) "ARB_precision_hint_nicest"
        .emit ARB_PRECISION_HINT_NICEST .load ARB_precision_hint_nicest 0x01 .or
    fp_ARB_fog_exp .emit ARB_FOG_EXP .load ARB_fog_exp 0x01 .or
    fp_ARB_fog_exp2 .emit ARB_FOG_EXP2 .load ARB_fog_exp2 0x01 .or
    fp_ARB_fog_linear .emit ARB_FOG_LINEAR .load ARB_fog_linear 0x01 .or
    .if (fragment_program_shadow != 0x00) "ARB_fragment_program_shadow"
        .emit ARB_FRAGMENT_PROGRAM_SHADOW .load ARB_fragment_program_shadow 0x01 .or
    .if (draw_buffers != 0x00) "ARB_draw_buffers" .emit ARB_DRAW_BUFFERS
        .load ARB_draw_buffers 0x01;
vp_optionString
    "ARB_position_invariant" .emit ARB_POSITION_INVARIANT .load ARB_position_invariant 0x01;
fp_ARB_fog_exp
    .if (ARB_fog_exp2 == 0x00) .true .and .if (ARB_fog_linear == 0x00) "ARB_fog_exp";
fp_ARB_fog_exp2
    .if (ARB_fog_exp == 0x00) .true .and .if (ARB_fog_linear == 0x00) "ARB_fog_exp2";
fp_ARB_fog_linear
    .if (ARB_fog_exp == 0x00) .true .and .if (ARB_fog_exp2 == 0x00) "ARB_fog_linear";

/*
    <statementSequence>    ::= <statementSequence> <statement>
                             | ""
*/
fp_statementSequence
    .loop fp_statement;
vp_statementSequence
    .loop vp_statement;

/*
    <statement>            ::= <instruction> ";"
                             | <namingStatement> ";"

NOTE: ".emit $" in the definitions below means that we output instruction position (offset of
      the first character of instruction) for program debugging purposes.
*/
fp_statement
    fp_statement_1 .or fp_statement_2;
vp_statement
    vp_statement_1 .or vp_statement_2;
fp_statement_1
    fp_instruction .emit INSTRUCTION .emit $ .and semicolon;
fp_statement_2
    fp_namingStatement .emit DECLARATION .and semicolon;
vp_statement_1
    vp_instruction .emit INSTRUCTION .emit $ .and semicolon;
vp_statement_2
    vp_namingStatement .emit DECLARATION .and semicolon;

/*
fragment program
    <instruction>          ::= <ALUInstruction>
                             | <TexInstruction>

vertex program
    <instruction>          ::= <ARL_instruction>
                             | <VECTORop_instruction>
                             | <SCALARop_instruction>
                             | <BINSCop_instruction>
                             | <BINop_instruction>
                             | <TRIop_instruction>
                             | <SWZ_instruction>
*/
fp_instruction
    ALUInstruction .emit OP_ALU_INST .or
    TexInstruction .emit OP_TEX_INST;
vp_instruction
    ARL_instruction .emit OP_ALU_ARL .or
    vp_VECTORop_instruction .emit OP_ALU_VECTOR .or
    vp_SCALARop_instruction .emit OP_ALU_SCALAR .or
    vp_BINSCop_instruction .emit OP_ALU_BINSC .or
    vp_BINop_instruction .emit OP_ALU_BIN .or
    vp_TRIop_instruction .emit OP_ALU_TRI .or
    vp_SWZ_instruction .emit OP_ALU_SWZ;

/*
fragment program
    <ALUInstruction>       ::= <VECTORop_instruction>
                             | <SCALARop_instruction>
                             | <BINSCop_instruction>
                             | <BINop_instruction>
                             | <TRIop_instruction>
                             | <SWZ_instruction>
*/
ALUInstruction
    fp_VECTORop_instruction .emit OP_ALU_VECTOR .or
    fp_SCALARop_instruction .emit OP_ALU_SCALAR .or
    fp_BINSCop_instruction .emit OP_ALU_BINSC .or
    fp_BINop_instruction .emit OP_ALU_BIN .or
    fp_TRIop_instruction .emit OP_ALU_TRI .or
    fp_SWZ_instruction .emit OP_ALU_SWZ;

/*
fragment program
    <TexInstruction>       ::= <SAMPLE_instruction>
                             | <KIL_instruction>
*/
TexInstruction
    SAMPLE_instruction .emit OP_TEX_SAMPLE .or
    KIL_instruction .emit OP_TEX_KIL;

/*
vertex program
    <ARL_instruction>      ::= "ARL" <maskedAddrReg> "," <scalarSrcReg>
*/
ARL_instruction
    "ARL" .emit OP_ARL .and space_dst .and maskedAddrReg .and comma .and vp_scalarSrcReg;

/*
fragment program
    <VECTORop_instruction> ::= <VECTORop> <maskedDstReg> "," 
                               <vectorSrcReg>

vertex program
    <VECTORop_instruction> ::= <VECTORop> <maskedDstReg> "," <swizzleSrcReg>
*/
fp_VECTORop_instruction
    fp_VECTORop .and space_dst .and fp_maskedDstReg .and comma .and vectorSrcReg;
vp_VECTORop_instruction
    vp_VECTORop .and space_dst .and vp_maskedDstReg .and comma .and swizzleSrcReg;

/*
fragment program
    <VECTORop>             ::= "ABS" | "ABS_SAT"
                             | "FLR" | "FLR_SAT"
                             | "FRC" | "FRC_SAT"
                             | "LIT" | "LIT_SAT"
                             | "MOV" | "MOV_SAT"

vertex program
    <VECTORop>             ::= "ABS"
                             | "FLR"
                             | "FRC"
                             | "LIT"
                             | "MOV"
*/
fp_VECTORop
    "ABS" .emit OP_ABS .or "ABS_SAT" .emit OP_ABS_SAT .or
    "FLR" .emit OP_FLR .or "FLR_SAT" .emit OP_FLR_SAT .or
    "FRC" .emit OP_FRC .or "FRC_SAT" .emit OP_FRC_SAT .or
    "LIT" .emit OP_LIT .or "LIT_SAT" .emit OP_LIT_SAT .or
    "MOV" .emit OP_MOV .or "MOV_SAT" .emit OP_MOV_SAT;
vp_VECTORop
    "ABS" .emit OP_ABS .or
    "FLR" .emit OP_FLR .or
    "FRC" .emit OP_FRC .or
    "LIT" .emit OP_LIT .or
    "MOV" .emit OP_MOV;

/*
    <SCALARop_instruction> ::= <SCALARop> <maskedDstReg> "," <scalarSrcReg>
*/
fp_SCALARop_instruction
    fp_SCALARop .and space_dst .and fp_maskedDstReg .and comma .and fp_scalarSrcReg;
vp_SCALARop_instruction
    vp_SCALARop .and space_dst .and vp_maskedDstReg .and comma .and vp_scalarSrcReg;

/*
fragment program
    <SCALARop>             ::= "COS" | "COS_SAT"
                             | "EX2" | "EX2_SAT"
                             | "LG2" | "LG2_SAT"
                             | "RCP" | "RCP_SAT"
                             | "RSQ" | "RSQ_SAT"
                             | "SIN" | "SIN_SAT"
                             | "SCS" | "SCS_SAT"

vertex program
    <SCALARop>             ::= "EX2"
                             | "EXP"
                             | "LG2"
                             | "LOG"
                             | "RCP"
                             | "RSQ"
*/
fp_SCALARop
    "COS" .emit OP_COS .or "COS_SAT" .emit OP_COS_SAT .or
    "EX2" .emit OP_EX2 .or "EX2_SAT" .emit OP_EX2_SAT .or
    "LG2" .emit OP_LG2 .or "LG2_SAT" .emit OP_LG2_SAT .or
    "RCP" .emit OP_RCP .or "RCP_SAT" .emit OP_RCP_SAT .or
    "RSQ" .emit OP_RSQ .or "RSQ_SAT" .emit OP_RSQ_SAT .or
    "SIN" .emit OP_SIN .or "SIN_SAT" .emit OP_SIN_SAT .or
    "SCS" .emit OP_SCS .or "SCS_SAT" .emit OP_SCS_SAT;
vp_SCALARop
    "EX2" .emit OP_EX2 .or
    "EXP" .emit OP_EXP .or
    "LG2" .emit OP_LG2 .or
    "LOG" .emit OP_LOG .or
    "RCP" .emit OP_RCP .or
    "RSQ" .emit OP_RSQ;

/*
    <BINSCop_instruction>  ::= <BINSCop> <maskedDstReg> "," <scalarSrcReg> ","
                               <scalarSrcReg>
*/
fp_BINSCop_instruction
    fp_BINSCop .and space_dst .and fp_maskedDstReg .and comma .and fp_scalarSrcReg .and comma .and
    fp_scalarSrcReg;
vp_BINSCop_instruction
    vp_BINSCop .and space_dst .and vp_maskedDstReg .and comma .and vp_scalarSrcReg .and comma .and
    vp_scalarSrcReg;

/*
fragment program
    <BINSCop>              ::= "POW" | "POW_SAT"

vertex program
    <BINSCop>              ::= "POW"
*/
fp_BINSCop
    "POW" .emit OP_POW .or "POW_SAT" .emit OP_POW_SAT;
vp_BINSCop
    "POW" .emit OP_POW;

/*
fragment program
    <BINop_instruction>    ::= <BINop> <maskedDstReg> ","
                               <vectorSrcReg> "," <vectorSrcReg>

vertex program
    <BINop_instruction>    ::= <BINop> <maskedDstReg> ","
                               <swizzleSrcReg> "," <swizzleSrcReg>
*/
fp_BINop_instruction
    fp_BINop .and space_dst .and fp_maskedDstReg .and comma .and vectorSrcReg .and comma .and
    vectorSrcReg;
vp_BINop_instruction
    vp_BINop .and space_dst .and vp_maskedDstReg .and comma .and swizzleSrcReg .and comma .and
    swizzleSrcReg;

/*
fragment program
    <BINop>                ::= "ADD" | "ADD_SAT"
                             | "DP3" | "DP3_SAT"
                             | "DP4" | "DP4_SAT"
                             | "DPH" | "DPH_SAT"
                             | "DST" | "DST_SAT"
                             | "MAX" | "MAX_SAT"
                             | "MIN" | "MIN_SAT"
                             | "MUL" | "MUL_SAT"
                             | "SGE" | "SGE_SAT"
                             | "SLT" | "SLT_SAT"
                             | "SUB" | "SUB_SAT"
                             | "XPD" | "XPD_SAT"

vertex program
    <BINop>                ::= "ADD"
                             | "DP3"
                             | "DP4"
                             | "DPH"
                             | "DST"
                             | "MAX"
                             | "MIN"
                             | "MUL"
                             | "SGE"
                             | "SLT"
                             | "SUB"
                             | "XPD"
*/
fp_BINop
    "ADD" .emit OP_ADD .or "ADD_SAT" .emit OP_ADD_SAT .or
    "DP3" .emit OP_DP3 .or "DP3_SAT" .emit OP_DP3_SAT .or
    "DP4" .emit OP_DP4 .or "DP4_SAT" .emit OP_DP4_SAT .or
    "DPH" .emit OP_DPH .or "DPH_SAT" .emit OP_DPH_SAT .or
    "DST" .emit OP_DST .or "DST_SAT" .emit OP_DST_SAT .or
    "MAX" .emit OP_MAX .or "MAX_SAT" .emit OP_MAX_SAT .or
    "MIN" .emit OP_MIN .or "MIN_SAT" .emit OP_MIN_SAT .or
    "MUL" .emit OP_MUL .or "MUL_SAT" .emit OP_MUL_SAT .or
    "SGE" .emit OP_SGE .or "SGE_SAT" .emit OP_SGE_SAT .or
    "SLT" .emit OP_SLT .or "SLT_SAT" .emit OP_SLT_SAT .or
    "SUB" .emit OP_SUB .or "SUB_SAT" .emit OP_SUB_SAT .or
    "XPD" .emit OP_XPD .or "XPD_SAT" .emit OP_XPD_SAT;
vp_BINop
    "ADD" .emit OP_ADD .or
    "DP3" .emit OP_DP3 .or
    "DP4" .emit OP_DP4 .or
    "DPH" .emit OP_DPH .or
    "DST" .emit OP_DST .or
    "MAX" .emit OP_MAX .or
    "MIN" .emit OP_MIN .or
    "MUL" .emit OP_MUL .or
    "SGE" .emit OP_SGE .or
    "SLT" .emit OP_SLT .or
    "SUB" .emit OP_SUB .or
    "XPD" .emit OP_XPD;

/*
fragment program
    <TRIop_instruction>    ::= <TRIop> <maskedDstReg> ","
                               <vectorSrcReg> "," <vectorSrcReg> ","
                               <vectorSrcReg>

vertex program
    <TRIop_instruction>    ::= <TRIop> <maskedDstReg> ","
                               <swizzleSrcReg> "," <swizzleSrcReg> ","
                               <swizzleSrcReg>
*/
fp_TRIop_instruction
    fp_TRIop .and space_dst .and fp_maskedDstReg .and comma .and vectorSrcReg .and comma .and
    vectorSrcReg .and comma .and vectorSrcReg;
vp_TRIop_instruction
    vp_TRIop .and space_dst .and vp_maskedDstReg .and comma .and swizzleSrcReg .and comma .and
    swizzleSrcReg .and comma .and swizzleSrcReg;

/*
fragment program
    <TRIop>                ::= "CMP" | "CMP_SAT"
                             | "LRP" | "LRP_SAT"
                             | "MAD" | "MAD_SAT"

vertex program
    <TRIop>                ::= "MAD"
*/
fp_TRIop
    "CMP" .emit OP_CMP .or "CMP_SAT" .emit OP_CMP_SAT .or
    "LRP" .emit OP_LRP .or "LRP_SAT" .emit OP_LRP_SAT .or
    "MAD" .emit OP_MAD .or "MAD_SAT" .emit OP_MAD_SAT;
vp_TRIop
    "MAD" .emit OP_MAD;

/*
fragment program
    <SWZ_instruction>      ::= <SWZop> <maskedDstReg> "," 
                               <srcReg> "," <extendedSwizzle>

vertex program
    <SWZ_instruction>      ::= "SWZ" <maskedDstReg> "," <srcReg> "," 
                               <extendedSwizzle>
*/
fp_SWZ_instruction
    SWZop .and space_dst .and fp_maskedDstReg .and comma .and fp_srcReg .and comma .and
    fp_extendedSwizzle .error EXT_SWIZ_COMP_EXPECTED;
vp_SWZ_instruction
    "SWZ" .emit OP_SWZ .and space_dst .and vp_maskedDstReg .and comma .and vp_srcReg .and comma .and
    vp_extendedSwizzle .error EXT_SWIZ_COMP_EXPECTED;

/*
fragment program
    <SWZop>                ::= "SWZ" | "SWZ_SAT"
*/
SWZop
    "SWZ" .emit OP_SWZ .or "SWZ_SAT" .emit OP_SWZ_SAT;

/*
fragment program
    <SAMPLE_instruction>   ::= <SAMPLEop> <maskedDstReg> ","
                               <vectorSrcReg> "," <texImageUnit> "," 
                               <texTarget>
*/
SAMPLE_instruction
    SAMPLEop .and space_dst .and fp_maskedDstReg .and comma .and vectorSrcReg .and comma .and
    texImageUnit .and comma .and texTarget .error TEX_TARGET_EXPECTED;

/*
fragment program
    <SAMPLEop>             ::= "TEX" | "TEX_SAT"
                             | "TXP" | "TXP_SAT"
                             | "TXB" | "TXB_SAT"
*/
SAMPLEop
    "TEX" .emit OP_TEX .or "TEX_SAT" .emit OP_TEX_SAT .or
    "TXB" .emit OP_TXB .or "TXB_SAT" .emit OP_TXB_SAT .or
    "TXP" .emit OP_TXP .or "TXP_SAT" .emit OP_TXP_SAT;

/*
fragment program
    <KIL_instruction>      ::= "KIL" <vectorSrcReg>
*/
KIL_instruction
    "KIL" .emit OP_KIL .and space_src .and vectorSrcReg;

/*
fragment program
    <texImageUnit>         ::= "texture" <optTexImageUnitNum>
*/
texImageUnit
    "texture" .error TEXTURE_EXPECTED .and optTexImageUnitNum;

/*
fragment program
    <texTarget>            ::= "1D"
                             | "2D"
                             | "3D"
                             | "CUBE"
                             | "RECT"
                             | <shadowTarget> (if option ARB_fragment_program_shadow present)
*/
texTarget
    "1D" .emit TEXTARGET_1D .or
    "2D" .emit TEXTARGET_2D .or
    "3D" .emit TEXTARGET_3D .or
    .if (texture_rectangle != 0x00) "RECT" .emit TEXTARGET_RECT .or
    "CUBE" .emit TEXTARGET_CUBE .or
    .if (ARB_fragment_program_shadow != 0x00) shadowTarget;

/*
GL_ARB_fragment_program_shadow
    <shadowTarget>         ::= "SHADOW1D"
                             | "SHADOW2D"
                             | "SHADOWRECT"
*/
shadowTarget
    "SHADOW1D" .emit TEXTARGET_SHADOW1D .or
    "SHADOW2D" .emit TEXTARGET_SHADOW2D .or
    .if (texture_rectangle != 0x00) "SHADOWRECT" .emit TEXTARGET_SHADOWRECT;

/*
fragment program
    <optTexImageUnitNum>   ::= ""
                             | "[" <texImageUnitNum> "]"
*/
optTexImageUnitNum
    optTexImageUnitNum_1 .or .true .emit 0x00;
optTexImageUnitNum_1
    lbracket_ne .and texImageUnitNum .and rbracket;

/*
fragment program
    <texImageUnitNum>      ::= <integer> from 0 to 
                               MAX_TEXTURE_IMAGE_UNITS_ARB-1
*/
texImageUnitNum
    integer;

/*
    <scalarSrcReg>         ::= <optionalSign> <srcReg> <scalarSuffix>
*/
fp_scalarSrcReg
    optionalSign .and fp_srcReg .and fp_scalarSuffix;
vp_scalarSrcReg
    optionalSign .and vp_srcReg .and vp_scalarSuffix;

/*
vertex program
    <swizzleSrcReg>        ::= <optionalSign> <srcReg> <swizzleSuffix>
*/
swizzleSrcReg
    optionalSign .and vp_srcReg .and swizzleSuffix;

/*
fragment program
    <vectorSrcReg>         ::= <optionalSign> <srcReg> <optionalSuffix> 
*/
vectorSrcReg
    optionalSign .and fp_srcReg .and optionalSuffix;

/*
    <maskedDstReg>         ::= <dstReg> <optionalMask>
*/
fp_maskedDstReg
    fp_dstReg .and fp_optionalMask;
vp_maskedDstReg
    vp_dstReg .and vp_optionalMask;

/*
vertex program
    <maskedAddrReg>        ::= <addrReg> <addrWriteMask>
*/
maskedAddrReg
    addrReg .error ADDRESS_REGISTER_EXPECTED .and addrWriteMask;

/*
fragment program
    <extendedSwizzle>      ::= <xyzwExtendedSwizzle>
                             | <rgbaExtendedSwizzle>

vertex program
    <extendedSwizzle>      ::= <extSwizComp> "," <extSwizComp> "," 
                                 <extSwizComp> "," <extSwizComp>

NOTE: do NOT change the order of <rgbaExtendedSwizzle> and <xyzwExtendedSwizzle> rulez
*/
fp_extendedSwizzle
    rgbaExtendedSwizzle .or xyzwExtendedSwizzle;
vp_extendedSwizzle
    extSwizComp .and comma .and
    extSwizComp .error EXT_SWIZ_COMP_EXPECTED .and comma .and
    extSwizComp .error EXT_SWIZ_COMP_EXPECTED .and comma .and
    extSwizComp .error EXT_SWIZ_COMP_EXPECTED;

/*
fragment program
    <xyzwExtendedSwizzle>  ::= <xyzwExtSwizComp> "," <xyzwExtSwizComp> "," 
                               <xyzwExtSwizComp> "," <xyzwExtSwizComp>
*/
xyzwExtendedSwizzle
    xyzwExtSwizComp .and comma .and
    xyzwExtSwizComp .error EXT_SWIZ_COMP_EXPECTED .and comma .and
    xyzwExtSwizComp .error EXT_SWIZ_COMP_EXPECTED .and comma .and
    xyzwExtSwizComp .error EXT_SWIZ_COMP_EXPECTED;

/*
fragment program
    <rgbaExtendedSwizzle>  ::= <rgbaExtSwizComp> "," <rgbaExtSwizComp> "," 
                               <rgbaExtSwizComp> "," <rgbaExtSwizComp>
*/
rgbaExtendedSwizzle
    rgbaExtendedSwizzle_1 .or rgbaExtendedSwizzle_2 .or rgbaExtendedSwizzle_3 .or
    rgbaExtendedSwizzle_4;
rgbaExtendedSwizzle_1
    rgbaExtSwizComp_digit .and comma .and rgbaExtSwizComp_digit .and comma .and
    rgbaExtSwizComp_digit .and comma .and rgbaExtSwizComp;
rgbaExtendedSwizzle_2
    rgbaExtSwizComp_digit .and comma .and rgbaExtSwizComp_digit .and comma .and
    rgbaExtSwizComp_alpha .and comma .and rgbaExtSwizComp .error EXT_SWIZ_COMP_EXPECTED;
rgbaExtendedSwizzle_3
    rgbaExtSwizComp_digit .and comma .and rgbaExtSwizComp_alpha .and comma .and
    rgbaExtSwizComp .error EXT_SWIZ_COMP_EXPECTED .and comma .and
    rgbaExtSwizComp .error EXT_SWIZ_COMP_EXPECTED;
rgbaExtendedSwizzle_4
    rgbaExtSwizComp_alpha .and comma .and 
    rgbaExtSwizComp .error EXT_SWIZ_COMP_EXPECTED .and comma .and
    rgbaExtSwizComp .error EXT_SWIZ_COMP_EXPECTED .and comma .and
    rgbaExtSwizComp .error EXT_SWIZ_COMP_EXPECTED;

/*
fragment program
    <xyzwExtSwizComp>      ::= <optionalSign> <xyzwExtSwizSel>
*/
xyzwExtSwizComp
    optionalSign .and xyzwExtSwizSel;

/*
fragment program
    <rgbaExtSwizComp>      ::= <optionalSign> <rgbaExtSwizSel>
*/
rgbaExtSwizComp
    optionalSign .and rgbaExtSwizSel;
rgbaExtSwizComp_digit
    optionalSign .and rgbaExtSwizSel_digit;
rgbaExtSwizComp_alpha
    optionalSign .and rgbaExtSwizSel_alpha;

/*
vertex program
    <extSwizComp>          ::= <optionalSign> <extSwizSel>
*/
extSwizComp
    optionalSign .and extSwizSel;

/*
fragment program
    <xyzwExtSwizSel>       ::= "0" 
                             | "1" 
                             | <xyzwComponent>
*/
xyzwExtSwizSel
    "0" .emit COMPONENT_0 .or "1" .emit COMPONENT_1 .or xyzwComponent_single;

/*
fragment program
    <rgbaExtSwizSel>       ::= "0" 
                             | "1" 
                             | <rgbaComponent>
*/
rgbaExtSwizSel
    rgbaExtSwizSel_digit .or rgbaExtSwizSel_alpha;
rgbaExtSwizSel_digit
    "0" .emit COMPONENT_0 .or "1" .emit COMPONENT_1;
rgbaExtSwizSel_alpha
    rgbaComponent_single;

/*
vertex program
    <extSwizSel>           ::= "0" 
                             | "1" 
                             | <component>
*/
extSwizSel
    "0" .emit COMPONENT_0 .or "1" .emit COMPONENT_1 .or vp_component_single;

/*
fragment program
    <srcReg>               ::= <fragmentAttribReg>
                             | <temporaryReg>
                             | <progParamReg>

vertex program
    <srcReg>               ::= <vertexAttribReg>
                             | <temporaryReg>
                             | <progParamReg>
*/
fp_srcReg
    fp_srcReg_1 .error SOURCE_REGISTER_EXPECTED;
vp_srcReg
    vp_srcReg_1 .error SOURCE_REGISTER_EXPECTED;
fp_srcReg_1
    fragmentAttribReg .emit REGISTER_ATTRIB .or
    fp_progParamReg .emit REGISTER_PARAM .or
    fp_temporaryReg .emit REGISTER_ESTABLISHED_NAME;
vp_srcReg_1
    vertexAttribReg .emit REGISTER_ATTRIB .or
    vp_progParamReg .emit REGISTER_PARAM .or
    vp_temporaryReg .emit REGISTER_ESTABLISHED_NAME;

/*
fragment program
    <dstReg>               ::= <temporaryReg>
                             | <fragmentResultReg>

vertex program
    <dstReg>               ::= <temporaryReg>
                             | <vertexResultReg>
*/
fp_dstReg
    fp_dstReg_1 .error DESTINATION_REGISTER_EXPECTED;
vp_dstReg
    vp_dstReg_1 .error DESTINATION_REGISTER_EXPECTED;
fp_dstReg_1
    fragmentResultReg .emit REGISTER_RESULT .or
    fp_temporaryReg .emit REGISTER_ESTABLISHED_NAME;
vp_dstReg_1
    vertexResultReg .emit REGISTER_RESULT .or
    vp_temporaryReg .emit REGISTER_ESTABLISHED_NAME;

/*
fragment program
    <fragmentAttribReg>    ::= <establishedName>
                             | <fragAttribBinding>

NOTE: <establishedName> is driven by <temporaryReg> rule at the end of <srcReg>
*/
fragmentAttribReg
    /*fp_establishedName .or */fragAttribBinding;

/*
vertex program
    <vertexAttribReg>      ::= <establishedName>
                             | <vtxAttribBinding>

NOTE: <establishedName> is driven by <temporaryReg> rule at the end of <srcReg>
*/
vertexAttribReg
    vtxAttribBinding;

/*
    <temporaryReg>         ::= <establishedName>
*/
fp_temporaryReg
    fp_establishedName_no_error_on_identifier;
vp_temporaryReg
    vp_establishedName_no_error_on_identifier;

/*
fragment program
    <progParamReg>         ::= <progParamSingle>
                             | <progParamArray> "[" <progParamArrayAbs> "]"
                             | <paramSingleItemUse>

vertex program
    <progParamReg>         ::= <progParamSingle>
                             | <progParamArray> "[" <progParamArrayMem> "]"
                             | <paramSingleItemUse>
*/
fp_progParamReg
    fp_paramSingleItemUse .or fp_progParamReg_1 .or fp_progParamSingle;
vp_progParamReg
    vp_paramSingleItemUse .or vp_progParamReg_1 .or vp_progParamSingle;
fp_progParamReg_1
    fp_progParamArray .emit PARAM_ARRAY_ELEMENT .and lbracket_ne .and progParamArrayAbs .and
    rbracket;
vp_progParamReg_1
    vp_progParamArray .emit PARAM_ARRAY_ELEMENT .and lbracket_ne .and progParamArrayMem .and
    rbracket;

/*
    <progParamSingle>      ::= <establishedName>

NOTE: <establishedName> is driven by <temporaryReg> rule at the end of <srcReg>
*/
fp_progParamSingle
    .false;
vp_progParamSingle
    .false;

/*
    <progParamArray>       ::= <establishedName>
*/
fp_progParamArray
    fp_establishedName_no_error_on_identifier;
vp_progParamArray
    vp_establishedName_no_error_on_identifier;

/*
vertex program
    <progParamArrayMem>    ::= <progParamArrayAbs>
                             | <progParamArrayRel>
*/
progParamArrayMem
    progParamArrayAbs .or progParamArrayRel;

/*
    <progParamArrayAbs>    ::= <integer>
*/
progParamArrayAbs
    integer_ne .emit ARRAY_INDEX_ABSOLUTE;

/*
vertex program
    <progParamArrayRel>    ::= <addrReg> <addrComponent> <addrRegRelOffset>
*/
progParamArrayRel
    addrReg .error ADDRESS_REGISTER_OR_INTEGER_EXPECTED .emit ARRAY_INDEX_RELATIVE .and
    addrComponent .and addrRegRelOffset;

/*
vertex program
    <addrRegRelOffset>     ::= ""
                             | "+" <addrRegPosOffset>
                             | "-" <addrRegNegOffset>
*/
addrRegRelOffset
    addrRegRelOffset_1 .or addrRegRelOffset_2 .or .true .emit 0x00;
addrRegRelOffset_1
    plus_ne .and addrRegPosOffset;
addrRegRelOffset_2
    minus_ne .and addrRegNegOffset;

/*
vertex program
    <addrRegPosOffset>     ::= <integer> from 0 to 63
*/
addrRegPosOffset
    integer_0_63;

/*
vertex program
    <addrRegNegOffset>     ::= <integer> from 0 to 64
*/
addrRegNegOffset
    integer_0_64;

/*
fragment program
    <fragmentResultReg>    ::= <establishedName>
                             | <resultBinding>

NOTE: <establishedName> is driven by <temporaryReg> rule at the end of <dstReg>
*/
fragmentResultReg
    fp_resultBinding;

/*
vertex program
    <vertexResultReg>      ::= <establishedName>
                             | <resultBinding>

NOTE: <establishedName> is driven by <temporaryReg> rule at the end of <dstReg>
*/
vertexResultReg
    vp_resultBinding;

/*
vertex program
    <addrReg>              ::= <establishedName>
*/
addrReg
    vp_establishedName_no_error_on_identifier;

/*
vertex program
    <addrComponent>        ::= "." "x"
*/
addrComponent
    dot .and "x" .error INVALID_ADDRESS_COMPONENT .emit COMPONENT_X .emit COMPONENT_X
    .emit COMPONENT_X .emit COMPONENT_X;

/*
vertex program
    <addrWriteMask>        ::= "." "x"
*/
addrWriteMask
    dot .and "x" .error INVALID_ADDRESS_WRITEMASK .emit 0x08;

/*
    <scalarSuffix>         ::= "." <component>
*/
fp_scalarSuffix
    dot .and fp_component_single .error INVALID_COMPONENT;
vp_scalarSuffix
    dot .and vp_component_single .error INVALID_COMPONENT;

/*
vertex program
    <swizzleSuffix>        ::= ""
                             | "." <component>
                             | "." <component> <component>
                                   <component> <component>
*/
swizzleSuffix
    swizzleSuffix_1 .or
    .true .emit COMPONENT_X .emit COMPONENT_Y .emit COMPONENT_Z .emit COMPONENT_W;
swizzleSuffix_1
    dot_ne .and swizzleSuffix_2 .error INVALID_SUFFIX;
swizzleSuffix_2
    swizzleSuffix_3 .or swizzleSuffix_4;
swizzleSuffix_3
    vp_component_multi .and vp_component_multi .and vp_component_multi .error INVALID_COMPONENT .and
    vp_component_multi .error INVALID_COMPONENT;
swizzleSuffix_4
    "x" .emit COMPONENT_X .emit COMPONENT_X .emit COMPONENT_X .emit COMPONENT_X .or
    "y" .emit COMPONENT_Y .emit COMPONENT_Y .emit COMPONENT_Y .emit COMPONENT_Y .or
    "z" .emit COMPONENT_Z .emit COMPONENT_Z .emit COMPONENT_Z .emit COMPONENT_Z .or
    "w" .emit COMPONENT_W .emit COMPONENT_W .emit COMPONENT_W .emit COMPONENT_W;

/*
fragment program
    <optionalSuffix>       ::= "" 
                             | "." <component> 
                             | "." <xyzwComponent> <xyzwComponent>
                                   <xyzwComponent> <xyzwComponent>
                             | "." <rgbaComponent> <rgbaComponent>
                                   <rgbaComponent> <rgbaComponent>
*/
optionalSuffix
    optionalSuffix_1 .or
    .true .emit COMPONENT_X .emit COMPONENT_Y .emit COMPONENT_Z .emit COMPONENT_W;
optionalSuffix_1
    dot_ne .and optionalSuffix_2 .error INVALID_SUFFIX;
optionalSuffix_2
    optionalSuffix_3 .or optionalSuffix_4 .or optionalSuffix_5;
optionalSuffix_3
    xyzwComponent_multi .and xyzwComponent_multi .and
    xyzwComponent_multi .error INVALID_COMPONENT .and xyzwComponent_multi .error INVALID_COMPONENT;
optionalSuffix_4
    rgbaComponent_multi .and rgbaComponent_multi .and
    rgbaComponent_multi .error INVALID_COMPONENT .and rgbaComponent_multi .error INVALID_COMPONENT;
optionalSuffix_5
    "x" .emit COMPONENT_X .emit COMPONENT_X .emit COMPONENT_X .emit COMPONENT_X .or
    "y" .emit COMPONENT_Y .emit COMPONENT_Y .emit COMPONENT_Y .emit COMPONENT_Y .or
    "z" .emit COMPONENT_Z .emit COMPONENT_Z .emit COMPONENT_Z .emit COMPONENT_Z .or
    "w" .emit COMPONENT_W .emit COMPONENT_W .emit COMPONENT_W .emit COMPONENT_W .or
    "r" .emit COMPONENT_X .emit COMPONENT_X .emit COMPONENT_X .emit COMPONENT_X .or
    "g" .emit COMPONENT_Y .emit COMPONENT_Y .emit COMPONENT_Y .emit COMPONENT_Y .or
    "b" .emit COMPONENT_Z .emit COMPONENT_Z .emit COMPONENT_Z .emit COMPONENT_Z .or
    "a" .emit COMPONENT_W .emit COMPONENT_W .emit COMPONENT_W .emit COMPONENT_W;

/*
fragment program
    <component>            ::= <xyzwComponent>
                             | <rgbaComponent>

vertex program
    <component>            ::= "x"
                             | "y"
                             | "z"
                             | "w"
*/
fp_component_single
    xyzwComponent_single .or rgbaComponent_single;
vp_component_multi
    'x' .emit COMPONENT_X .or 'y' .emit COMPONENT_Y .or 'z' .emit COMPONENT_Z .or
    'w' .emit COMPONENT_W;
vp_component_single
    "x" .emit COMPONENT_X .or "y" .emit COMPONENT_Y .or "z" .emit COMPONENT_Z .or
    "w" .emit COMPONENT_W;

/*
fragment program
    <xyzwComponent>        ::= "x" | "y" | "z" | "w"
*/
xyzwComponent_multi
    'x' .emit COMPONENT_X .or 'y' .emit COMPONENT_Y .or 'z' .emit COMPONENT_Z .or
    'w' .emit COMPONENT_W;
xyzwComponent_single
    "x" .emit COMPONENT_X .or "y" .emit COMPONENT_Y .or "z" .emit COMPONENT_Z .or
    "w" .emit COMPONENT_W;

/*
fragment program
    <rgbaComponent>        ::= "r" | "g" | "b" | "a"
*/
rgbaComponent_multi
    'r' .emit COMPONENT_X .or 'g' .emit COMPONENT_Y .or 'b' .emit COMPONENT_Z .or
    'a' .emit COMPONENT_W;
rgbaComponent_single
    "r" .emit COMPONENT_X .or "g" .emit COMPONENT_Y .or "b" .emit COMPONENT_Z .or
    "a" .emit COMPONENT_W;

/*
fragment program
    <optionalMask>         ::= ""
                             | <xyzwMask>
                             | <rgbaMask>

vertex program
    <optionalMask>         ::= ""
                             | "." "x"
                             | "." "y"
                             | "." "xy"
                             | "." "z"
                             | "." "xz"
                             | "." "yz"
                             | "." "xyz"
                             | "." "w"
                             | "." "xw"
                             | "." "yw"
                             | "." "xyw"
                             | "." "zw"
                             | "." "xzw"
                             | "." "yzw"
                             | "." "xyzw"

NOTE: do NOT change the order of <rgbaMask> and <xyzwMask> rulez
*/
fp_optionalMask
    rgbaMask .or xyzwMask .or .true .emit 0x0F;
vp_optionalMask
    xyzwMask .or .true .emit 0x0F;

/*
fragment program
    <xyzwMask>             ::= "." "x"
                             | "." "y"
                             | "." "xy"
                             | "." "z"
                             | "." "xz"
                             | "." "yz"
                             | "." "xyz"
                             | "." "w"
                             | "." "xw"
                             | "." "yw"
                             | "." "xyw"
                             | "." "zw"
                             | "." "xzw"
                             | "." "yzw"
                             | "." "xyzw"

NOTE: <xyzwMask> is also referenced by the vertex program symbol <optionalMask>.
*/
xyzwMask
    dot_ne .and xyzwMask_1 .error INVALID_WRITEMASK;
xyzwMask_1
    "xyzw" .emit 0x0F .or "xyz" .emit 0x0E .or "xyw" .emit 0x0D .or "xy" .emit 0x0C .or
    "xzw" .emit 0x0B .or "xz" .emit 0x0A .or "xw" .emit 0x09 .or "x" .emit 0x08 .or
    "yzw" .emit 0x07 .or "yz" .emit 0x06 .or "yw" .emit 0x05 .or "y" .emit 0x04 .or
    "zw" .emit 0x03 .or "z" .emit 0x02 .or "w" .emit 0x01;

/*
fragment program
    <rgbaMask>             ::= "." "r"
                             | "." "g"
                             | "." "rg"
                             | "." "b"
                             | "." "rb"
                             | "." "gb"
                             | "." "rgb"
                             | "." "a"
                             | "." "ra"
                             | "." "ga"
                             | "." "rga"
                             | "." "ba"
                             | "." "rba"
                             | "." "gba"
                             | "." "rgba"
*/
rgbaMask
    dot_ne .and rgbaMask_1;
rgbaMask_1
    "rgba" .emit 0x0F .or "rgb" .emit 0x0E .or "rga" .emit 0x0D .or "rg" .emit 0x0C .or
    "rba" .emit 0x0B .or "rb" .emit 0x0A .or "ra" .emit 0x09 .or "r" .emit 0x08 .or
    "gba" .emit 0x07 .or "gb" .emit 0x06 .or "ga" .emit 0x05 .or "g" .emit 0x04 .or
    "ba" .emit 0x03 .or "b" .emit 0x02 .or "a" .emit 0x01;

/*
fragment program
    <namingStatement>      ::= <ATTRIB_statement>
                             | <PARAM_statement>
                             | <TEMP_statement>
                             | <OUTPUT_statement>
                             | <ALIAS_statement>

vertex program
    <namingStatement>      ::= <ATTRIB_statement>
                             | <PARAM_statement>
                             | <TEMP_statement>
                             | <ADDRESS_statement>
                             | <OUTPUT_statement>
                             | <ALIAS_statement>
*/
fp_namingStatement
    fp_ATTRIB_statement .emit ATTRIB .or
    fp_PARAM_statement .emit PARAM .or
    fp_TEMP_statement .emit TEMP .or
    fp_OUTPUT_statement .emit OUTPUT .or
    fp_ALIAS_statement .emit ALIAS;
vp_namingStatement
    vp_ATTRIB_statement .emit ATTRIB .or
    vp_PARAM_statement .emit PARAM .or
    vp_TEMP_statement .emit TEMP .or
    ADDRESS_statement .emit ADDRESS .or
    vp_OUTPUT_statement .emit OUTPUT .or
    vp_ALIAS_statement .emit ALIAS;

/*
fragment program
    <ATTRIB_statement>     ::= "ATTRIB" <establishName> "="
                                 <fragAttribBinding>

vertex program
    <ATTRIB_statement>     ::= "ATTRIB" <establishName> "="
                                 <vtxAttribBinding>
*/
fp_ATTRIB_statement
    "ATTRIB" .and space .and fp_establishName .and equal .and
    fragAttribBinding .error FRAGMENT_EXPECTED;
vp_ATTRIB_statement
    "ATTRIB" .and space .and vp_establishName .and equal .and
    vtxAttribBinding .error VERTEX_EXPECTED;

/*
fragment program
    <fragAttribBinding>    ::= "fragment" "." <fragAttribItem>
*/
fragAttribBinding
    "fragment" .and dot .and fragAttribItem .error INVALID_FRAGMENT_PROPERTY;

/*
vertex program
    <vtxAttribBinding>     ::= "vertex" "." <vtxAttribItem>
*/
vtxAttribBinding
    "vertex" .and dot .and vtxAttribItem .error INVALID_VERTEX_PROPERTY;

/*
fragment program
    <fragAttribItem>       ::= "color" <optColorType>
                             | "texcoord" <optTexCoordNum>
                             | "fogcoord"
                             | "position"
*/
fragAttribItem
    fragAttribItem_1 .emit FRAGMENT_ATTRIB_COLOR .or
    fragAttribItem_2 .emit FRAGMENT_ATTRIB_TEXCOORD .or
    .if (fog_coord != 0x00) "fogcoord" .emit FRAGMENT_ATTRIB_FOGCOORD .or
    "position" .emit FRAGMENT_ATTRIB_POSITION;
fragAttribItem_1
    "color" .and optColorType;
fragAttribItem_2
    "texcoord" .and optTexCoordNum;

/*
vertex program
    <vtxAttribItem>        ::= "position"
                             | "weight" <vtxOptWeightNum>
                             | "normal"
                             | "color" <optColorType>
                             | "fogcoord"
                             | "texcoord" <optTexCoordNum>
                             | "matrixindex" "[" <vtxWeightNum> "]"
                             | "attrib" "[" <vtxAttribNum> "]"
*/
vtxAttribItem
    "position" .emit VERTEX_ATTRIB_POSITION .or
    .if (vertex_blend != 0x00) vtxAttribItem_1 .emit VERTEX_ATTRIB_WEIGHT .or
    "normal" .emit VERTEX_ATTRIB_NORMAL .or
    vtxAttribItem_2 .emit VERTEX_ATTRIB_COLOR .or
    "fogcoord" .emit VERTEX_ATTRIB_FOGCOORD .or
    vtxAttribItem_3 .emit VERTEX_ATTRIB_TEXCOORD .or
    .if (matrix_palette != 0x00) vtxAttribItem_4 .emit VERTEX_ATTRIB_MATRIXINDEX .or
    vtxAttribItem_5 .emit VERTEX_ATTRIB_GENERIC;
vtxAttribItem_1
    "weight" .and vtxOptWeightNum;
vtxAttribItem_2
    "color" .and optColorType;
vtxAttribItem_3
    "texcoord" .and optTexCoordNum;
vtxAttribItem_4
    "matrixindex" .and lbracket .and vtxWeightNum .and rbracket;
vtxAttribItem_5
    "attrib" .and lbracket .and vtxAttribNum .and rbracket;

/*
vertex program
    <vtxAttribNum>         ::= <integer> from 0 to MAX_VERTEX_ATTRIBS_ARB-1
*/
vtxAttribNum
    integer;

/*
vertex program
    <vtxOptWeightNum>      ::= ""
                             | "[" <vtxWeightNum> "]"
*/
vtxOptWeightNum
    vtxOptWeightNum_1 .or .true .emit 0x00;
vtxOptWeightNum_1
    lbracket_ne .and vtxWeightNum .and rbracket;

/*
vertex program
    <vtxWeightNum>         ::= <integer> from 0 to MAX_VERTEX_UNITS_ARB-1,
                                 must be divisible by four
*/
vtxWeightNum
    integer;

/*
    <PARAM_statement>      ::= <PARAM_singleStmt>
                             | <PARAM_multipleStmt>
*/
fp_PARAM_statement
    fp_PARAM_multipleStmt .or fp_PARAM_singleStmt;
vp_PARAM_statement
    vp_PARAM_multipleStmt .or vp_PARAM_singleStmt;

/*
    <PARAM_singleStmt>     ::= "PARAM" <establishName> <paramSingleInit>
*/
fp_PARAM_singleStmt
    "PARAM" .and space .and fp_establishName .and .true .emit 0x00 .and fp_paramSingleInit .and
    .true .emit PARAM_NULL;
vp_PARAM_singleStmt
    "PARAM" .and space .and vp_establishName .and .true .emit 0x00 .and vp_paramSingleInit .and
    .true .emit PARAM_NULL;

/*
    <PARAM_multipleStmt>   ::= "PARAM" <establishName> "[" <optArraySize> "]"
                                   <paramMultipleInit>
*/
fp_PARAM_multipleStmt
    "PARAM" .and space .and fp_establishName .and lbracket_ne .and optArraySize .and rbracket .and
    fp_paramMultipleInit .and .true .emit PARAM_NULL;
vp_PARAM_multipleStmt
    "PARAM" .and space .and vp_establishName .and lbracket_ne .and optArraySize .and rbracket .and
    vp_paramMultipleInit .and .true .emit PARAM_NULL;

/*
    <optArraySize>         ::= ""
                             | <integer> from 1 to MAX_PROGRAM_PARAMETERS_ARB
                                 (maximum number of allowed program 
                                  parameter bindings)
*/
optArraySize
    optional_integer;

/*
    <paramSingleInit>      ::= "=" <paramSingleItemDecl>
*/
fp_paramSingleInit
    equal .and fp_paramSingleItemDecl;
vp_paramSingleInit
    equal .and vp_paramSingleItemDecl;

/*
    <paramMultipleInit>    ::= "=" "{" <paramMultInitList> "}"
*/
fp_paramMultipleInit
    equal .and lbrace .and fp_paramMultInitList .and rbrace;
vp_paramMultipleInit
    equal .and lbrace .and vp_paramMultInitList .and rbrace;

/*
    <paramMultInitList>    ::= <paramMultipleItem>
                             | <paramMultipleItem> "," <paramMultiInitList>
*/
fp_paramMultInitList
    fp_paramMultInitList_1 .or fp_paramMultipleItem;
vp_paramMultInitList
    vp_paramMultInitList_1 .or vp_paramMultipleItem;
fp_paramMultInitList_1
    fp_paramMultipleItem .and comma_ne .and fp_paramMultInitList;
vp_paramMultInitList_1
    vp_paramMultipleItem .and comma_ne .and vp_paramMultInitList;

/*
    <paramSingleItemDecl>  ::= <stateSingleItem>
                             | <programSingleItem>
                             | <paramConstDecl>
*/
fp_paramSingleItemDecl
    fp_stateSingleItem .emit PARAM_STATE_ELEMENT .or
    programSingleItem .emit PARAM_PROGRAM_ELEMENT .or
    paramConstDecl .emit PARAM_CONSTANT;
vp_paramSingleItemDecl
    vp_stateSingleItem .emit PARAM_STATE_ELEMENT .or
    programSingleItem .emit PARAM_PROGRAM_ELEMENT .or
    paramConstDecl .emit PARAM_CONSTANT;

/*
    <paramSingleItemUse>   ::= <stateSingleItem>
                             | <programSingleItem>
                             | <paramConstUse>
*/
fp_paramSingleItemUse
    fp_stateSingleItem .emit PARAM_STATE_ELEMENT .or
    programSingleItem .emit PARAM_PROGRAM_ELEMENT .or
    paramConstUse .emit PARAM_CONSTANT;
vp_paramSingleItemUse
    vp_stateSingleItem .emit PARAM_STATE_ELEMENT .or
    programSingleItem .emit PARAM_PROGRAM_ELEMENT .or
    paramConstUse .emit PARAM_CONSTANT;

/*
    <paramMultipleItem>    ::= <stateMultipleItem>
                             | <programMultipleItem>
                             | <paramConstDecl>
*/
fp_paramMultipleItem
    fp_stateMultipleItem .emit PARAM_STATE_ELEMENT .or
    programMultipleItem .emit PARAM_PROGRAM_ELEMENT .or
    paramConstDecl .emit PARAM_CONSTANT;
vp_paramMultipleItem
    vp_stateMultipleItem .emit PARAM_STATE_ELEMENT .or
    programMultipleItem .emit PARAM_PROGRAM_ELEMENT .or
    paramConstDecl .emit PARAM_CONSTANT;

/*
    <stateMultipleItem>    ::= <stateSingleItem>
                             | "state" "." <stateMatrixRows>
*/
fp_stateMultipleItem
    stateMultipleItem_1 .or fp_stateSingleItem;
vp_stateMultipleItem
    stateMultipleItem_1 .or vp_stateSingleItem;
stateMultipleItem_1
    "state" .and dot .and stateMatrixRows .emit STATE_MATRIX_ROWS;

/*
fragment program
    <stateSingleItem>      ::= "state" "." <stateMaterialItem>
                             | "state" "." <stateLightItem>
                             | "state" "." <stateLightModelItem>
                             | "state" "." <stateLightProdItem>
                             | "state" "." <stateTexEnvItem>
                             | "state" "." <stateFogItem>
                             | "state" "." <stateDepthItem>
                             | "state" "." <stateMatrixRow>

vertex program
    <stateSingleItem>      ::= "state" "." <stateMaterialItem>
                             | "state" "." <stateLightItem>
                             | "state" "." <stateLightModelItem>
                             | "state" "." <stateLightProdItem>
                             | "state" "." <stateTexGenItem>
                             | "state" "." <stateFogItem>
                             | "state" "." <stateClipPlaneItem>
                             | "state" "." <statePointItem>
                             | "state" "." <stateMatrixRow>
*/
fp_stateSingleItem
    "state" .and dot .and fp_stateSingleItem_1 .error INVALID_STATE_PROPERTY;
vp_stateSingleItem
    "state" .and dot .and vp_stateSingleItem_1 .error INVALID_STATE_PROPERTY;
fp_stateSingleItem_1
    stateSingleItem_1 .or stateSingleItem_2 .or stateSingleItem_3 .or stateSingleItem_4 .or
    stateSingleItem_5 .or stateSingleItem_7 .or stateSingleItem_8 .or stateSingleItem_11;
vp_stateSingleItem_1
    stateSingleItem_1 .or stateSingleItem_2 .or stateSingleItem_3 .or stateSingleItem_4 .or
    stateSingleItem_6 .or stateSingleItem_7 .or stateSingleItem_9 .or stateSingleItem_10 .or
    stateSingleItem_11;
stateSingleItem_1
    stateMaterialItem .emit STATE_MATERIAL;
stateSingleItem_2
    stateLightItem .emit STATE_LIGHT;
stateSingleItem_3
    stateLightModelItem .emit STATE_LIGHT_MODEL;
stateSingleItem_4
    stateLightProdItem .emit STATE_LIGHT_PROD;
stateSingleItem_5
    stateTexEnvItem .emit STATE_TEX_ENV;
stateSingleItem_6
    stateTexGenItem .emit STATE_TEX_GEN;
stateSingleItem_7
    stateFogItem .emit STATE_FOG;
stateSingleItem_8
    stateDepthItem .emit STATE_DEPTH;
stateSingleItem_9
    stateClipPlaneItem .emit STATE_CLIP_PLANE;
stateSingleItem_10
    statePointItem .emit STATE_POINT;
stateSingleItem_11
    stateMatrixRow .emit STATE_MATRIX_ROWS;

/*
    <stateMaterialItem>    ::= "material" <optFaceType> "." <stateMatProperty>
*/
stateMaterialItem
    "material" .and optFaceType .and dot .and stateMatProperty .error INVALID_MATERIAL_PROPERTY;

/*
    <stateMatProperty>     ::= "ambient"
                             | "diffuse"
                             | "specular"
                             | "emission"
                             | "shininess"
*/
stateMatProperty
    "ambient" .emit MATERIAL_AMBIENT .or
    "diffuse" .emit MATERIAL_DIFFUSE .or
    "specular" .emit MATERIAL_SPECULAR .or
    "emission" .emit MATERIAL_EMISSION .or
    "shininess" .emit MATERIAL_SHININESS;

/*
    <stateLightItem>       ::= "light" "[" <stateLightNumber> "]" "." 
                                 <stateLightProperty>
*/
stateLightItem
    "light" .and lbracket .and stateLightNumber .and rbracket .and dot .and
    stateLightProperty .error INVALID_LIGHT_PROPERTY;

/*
    <stateLightProperty>   ::= "ambient"
                             | "diffuse" 
                             | "specular"
                             | "position"
                             | "attenuation"
                             | "spot" "." <stateSpotProperty>
                             | "half"
*/
stateLightProperty
    "ambient" .emit LIGHT_AMBIENT .or
    "diffuse" .emit LIGHT_DIFFUSE .or
    "specular" .emit LIGHT_SPECULAR .or
    "position" .emit LIGHT_POSITION .or
    "attenuation" .emit LIGHT_ATTENUATION .or
    stateLightProperty_1 .emit LIGHT_SPOT_DIRECTION .or
    "half" .emit LIGHT_HALF;
stateLightProperty_1
    "spot" .and dot .and stateSpotProperty .error INVALID_SPOT_PROPERTY;

/*
    <stateSpotProperty>    ::= "direction" 
*/
stateSpotProperty
    "direction";

/*
    <stateLightModelItem>  ::= "lightmodel" <stateLModProperty>
*/
stateLightModelItem
    "lightmodel" .and stateLModProperty .error INVALID_LIGHTMODEL_PROPERTY;

/*
    <stateLModProperty>    ::= "." "ambient"
                             | <optFaceType> "." "scenecolor"
*/
stateLModProperty
    stateLModProperty_1 .or stateLModProperty_2;
stateLModProperty_1
    dot .and "ambient" .emit LIGHT_MODEL_AMBIENT;
stateLModProperty_2
    stateLModProperty_3 .emit LIGHT_MODEL_SCENECOLOR;
stateLModProperty_3
    optFaceType .and dot .and "scenecolor";

/*
    <stateLightProdItem>   ::= "lightprod" "[" <stateLightNumber> "]"
                                 <optFaceType> "." <stateLProdProperty>
*/
stateLightProdItem
    "lightprod" .and lbracket .and stateLightNumber .and rbracket .and optFaceType .and dot .and
    stateLProdProperty .error INVALID_LIGHTPROD_PROPERTY;

/*
    <stateLProdProperty>   ::= "ambient"
                             | "diffuse"
                             | "specular"
*/
stateLProdProperty
    "ambient" .emit LIGHT_PROD_AMBIENT .or
    "diffuse" .emit LIGHT_PROD_DIFFUSE .or
    "specular" .emit LIGHT_PROD_SPECULAR;

/*
    <stateLightNumber>     ::= <integer> from 0 to MAX_LIGHTS-1
*/
stateLightNumber
    integer;

/*
fragment program
    <stateTexEnvItem>      ::= "texenv" <optLegacyTexUnitNum> "." 
                                 <stateTexEnvProperty>
*/
stateTexEnvItem
    "texenv" .and optLegacyTexUnitNum .and dot .and
    stateTexEnvProperty .error INVALID_TEXENV_PROPERTY;

/*
fragment program
    <stateTexEnvProperty>  ::= "color"
*/
stateTexEnvProperty
    "color" .emit TEX_ENV_COLOR;

/*
fragment program
    <optLegacyTexUnitNum>  ::= ""
                             | "[" <legacyTexUnitNum> "]"

NOTE: <optLegaceTexUnitNum> is not optional.
*/
optLegacyTexUnitNum
    lbracket_ne .and legacyTexUnitNum .and rbracket;

/*
fragment program
    <legacyTexUnitNum>     ::= <integer> from 0 to MAX_TEXTURE_UNITS-1
*/
legacyTexUnitNum
    integer;

/*
vertex program
    <stateTexGenItem>      ::= "texgen" <optTexCoordNum> "."
                                 <stateTexGenType> "." <stateTexGenCoord>
*/
stateTexGenItem
    "texgen" .and optTexCoordNum .and dot .and stateTexGenType .error INVALID_TEXGEN_PROPERTY .and
    dot .and stateTexGenCoord .error INVALID_TEXGEN_COORD;

/*
vertex program
    <stateTexGenType>      ::= "eye"
                             | "object"
*/
stateTexGenType
    "eye" .emit TEX_GEN_EYE .or
    "object" .emit TEX_GEN_OBJECT;

/*
vertex program
    <stateTexGenCoord>     ::= "s"
                             | "t"
                             | "r"
                             | "q"
*/
stateTexGenCoord
    "s" .emit COMPONENT_X .or
    "t" .emit COMPONENT_Y .or
    "r" .emit COMPONENT_Z .or
    "q" .emit COMPONENT_W;

/*
    <stateFogItem>         ::= "fog" "." <stateFogProperty>
*/
stateFogItem
    "fog" .and dot .and stateFogProperty .error INVALID_FOG_PROPERTY;

/*
    <stateFogProperty>     ::= "color"
                             | "params"
*/
stateFogProperty
    "color" .emit FOG_COLOR .or
    "params" .emit FOG_PARAMS;

/*
fragment program
    <stateDepthItem>       ::= "depth" "." <stateDepthProperty>
*/
stateDepthItem
    "depth" .and dot .and stateDepthProperty .error INVALID_DEPTH_PROPERTY;

/*
fragment program
    <stateDepthProperty>   ::= "range"
*/
stateDepthProperty
    "range" .emit DEPTH_RANGE;

/*
vertex program
    <stateClipPlaneItem>   ::= "clip" "[" <stateClipPlaneNum> "]" "." "plane"
*/
stateClipPlaneItem
    "clip" .and lbracket .and stateClipPlaneNum .and rbracket .and dot .and
    "plane" .error INVALID_CLIPPLANE_PROPERTY;

/*
vertex program
    <stateClipPlaneNum>    ::= <integer> from 0 to MAX_CLIP_PLANES-1
*/
stateClipPlaneNum
    integer;

/*
vertex program
    <statePointItem>       ::= "point" "." <statePointProperty>
*/
statePointItem
    "point" .and dot .and statePointProperty .error INVALID_POINT_PROPERTY;

/*
vertex program
    <statePointProperty>   ::= "size"
                             | "attenuation"
*/
statePointProperty
    "size" .emit POINT_SIZE .or
    .if (point_parameters != 0x00) "attenuation" .emit POINT_ATTENUATION;

/*
    <stateMatrixRow>       ::= <stateMatrixItem> "." "row" "[" 
                                  <stateMatrixRowNum> "]"
*/
stateMatrixRow
    stateMatrixItem .and dot .and "row" .error MATRIX_ROW_SELECTOR_OR_MODIFIER_EXPECTED .and
    lbracket .and stateMatrixRowNum .and rbracket .emit 0x0;

/*
    <stateMatrixRows>      ::= <stateMatrixItem> <optMatrixRows>
*/
stateMatrixRows
    stateMatrixItem .and optMatrixRows;

/*
    <optMatrixRows>        ::= ""
                             | "." "row" "[" <stateMatrixRowNum> ".." 
                                  <stateMatrixRowNum> "]"
*/
optMatrixRows
    optMatrixRows_1 .or .true .emit 0x0 .emit '3' .emit 0x0 .emit $;
optMatrixRows_1
    dot_ne .and "row" .error MATRIX_ROW_SELECTOR_OR_MODIFIER_EXPECTED .and lbracket .and
    stateMatrixRowNum .and dotdot .and stateMatrixRowNum .and rbracket;

/*
    <stateMatrixItem>      ::= "matrix" "." <stateMatrixName> 
                               <stateOptMatModifier>
*/
stateMatrixItem
    "matrix" .and dot .and stateMatrixName .error INVALID_MATRIX_NAME .and stateOptMatModifier;

/*
    <stateOptMatModifier>  ::= ""
                             | "." <stateMatModifier>
*/
stateOptMatModifier
    stateOptMatModifier_1 .or .true .emit MATRIX_MODIFIER_IDENTITY;
stateOptMatModifier_1
    dot_ne .and stateMatModifier;

/*
    <stateMatModifier>     ::= "inverse" 
                             | "transpose" 
                             | "invtrans"
*/
stateMatModifier
    "inverse" .emit MATRIX_MODIFIER_INVERSE .or
    "transpose" .emit MATRIX_MODIFIER_TRANSPOSE .or
    "invtrans" .emit MATRIX_MODIFIER_INVTRANS;

/*
    <stateMatrixRowNum>    ::= <integer> from 0 to 3
*/
stateMatrixRowNum
    integer_0_3;

/*
    <stateMatrixName>      ::= "modelview" <stateOptModMatNum>
                             | "projection"
                             | "mvp"
                             | "texture" <optTexCoordNum>
                             | "palette" "[" <statePaletteMatNum> "]"
                             | "program" "[" <stateProgramMatNum> "]"
*/
stateMatrixName
    stateMatrixName_1_1 .emit MATRIX_MODELVIEW .or
    "projection" .emit MATRIX_PROJECTION .or
    "mvp" .emit MATRIX_MVP .or
    stateMatrixName_1_2 .emit MATRIX_TEXTURE .or
    .if (matrix_palette != 0x00) stateMatrixName_1_3 .emit MATRIX_PALETTE .or
    stateMatrixName_1_4 .emit MATRIX_PROGRAM;
stateMatrixName_1_1
    "modelview" .and stateOptModMatNum;
stateMatrixName_1_2
    "texture" .and optTexCoordNum;
stateMatrixName_1_3
    "palette" .and lbracket .and statePaletteMatNum .and rbracket;
stateMatrixName_1_4
    "program" .and lbracket .and stateProgramMatNum .and rbracket;

/*
    <stateOptModMatNum>    ::= ""
                             | "[" <stateModMatNum> "]"
*/
stateOptModMatNum
    .if (vertex_blend != 0x00) stateOptModMatNum_1 .or
    .true .emit 0x00;
stateOptModMatNum_1
    lbracket_ne .and stateModMatNum .and rbracket;

/*
    <stateModMatNum>       ::= <integer> from 0 to MAX_VERTEX_UNITS_ARB-1
*/
stateModMatNum
    integer;

/*
    <optTexCoordNum>       ::= ""
                             | "[" <texCoordNum> "]"
*/
optTexCoordNum
    optTexCoordNum_1 .or .true .emit 0x00;
optTexCoordNum_1
    lbracket_ne .and texCoordNum .and rbracket;

/*
    <texCoordNum>          ::= <integer> from 0 to MAX_TEXTURE_COORDS_ARB-1
*/
texCoordNum
    integer;

/*
    <statePaletteMatNum>   ::= <integer> from 0 to MAX_PALETTE_MATRICES_ARB-1
*/
statePaletteMatNum
    integer;

/*
    <stateProgramMatNum>   ::= <integer> from 0 to MAX_PROGRAM_MATRICES_ARB-1
*/
stateProgramMatNum
    integer;

/*
    <programSingleItem>    ::= <progEnvParam>
                             | <progLocalParam>

NOTE: <programSingleItem> has been modified for correct error handling. If program property
      is neither "env" nor "local" INVALID_PROGRAM_PROPERTY is generated.
*/
programSingleItem
    "program" .and dot .and programSingleItem_1 .error INVALID_PROGRAM_PROPERTY;
programSingleItem_1
    progEnvParam .or progLocalParam;

/*
    <programMultipleItem>  ::= <progEnvParams>
                             | <progLocalParams>

NOTE: <programMultipleItem> has been modified for correct error handling. If program property
      is neither "env" nor "local" INVALID_PROGRAM_PROPERTY is generated.
*/
programMultipleItem
    "program" .and dot .and programMultipleItem_1 .error INVALID_PROGRAM_PROPERTY;
programMultipleItem_1
    progEnvParams .or progLocalParams;

/*
    <progEnvParams>        ::= "program" "." "env" 
                                 "[" <progEnvParamNums> "]"

NOTE: "program" "." has been moved to <programMultipleItem>.
*/
progEnvParams
    "env" .emit PROGRAM_PARAM_ENV .and lbracket .and progEnvParamNums .and rbracket;

/*
    <progEnvParamNums>     ::= <progEnvParamNum>
                             | <progEnvParamNum> ".." <progEnvParamNum>
*/
progEnvParamNums
    progEnvParamNums_1 .or progEnvParamNums_2;
progEnvParamNums_1
    progEnvParamNum .and dotdot_ne .and progEnvParamNum;
progEnvParamNums_2
    progEnvParamNum .and .true .emit 0x00;

/*
    <progEnvParam>         ::= "program" "." "env" 
                                 "[" <progEnvParamNum> "]"

NOTE: "program" "." has been moved to <programSingleItem>.
*/
progEnvParam
    "env" .emit PROGRAM_PARAM_ENV .and lbracket .and progEnvParamNum .and rbracket .emit 0x00;

/*
    <progLocalParams>      ::= "program" "." "local" 
                                 "[" <progLocalParamNums> "]"

NOTE: "program" "." has been moved to <programMultipleItem>.
*/
progLocalParams
    "local" .emit PROGRAM_PARAM_LOCAL .and lbracket .and progLocalParamNums .and rbracket;

/*
    <progLocalParamNums>   ::= <progLocalParamNum>
                             | <progLocalParamNum> ".." <progLocalParamNum>
*/
progLocalParamNums
    progLocalParamNums_1 .or progLocalParamNums_2;
progLocalParamNums_1
    progLocalParamNum .and dotdot_ne .and progLocalParamNum;
progLocalParamNums_2
    progLocalParamNum .and .true .emit 0x00;

/*
    <progLocalParam>       ::= "program" "." "local" 
                                 "[" <progLocalParamNum> "]"

NOTE: "program" "." has been moved to <programSingleItem>.
*/
progLocalParam
    "local" .emit PROGRAM_PARAM_LOCAL .and lbracket .and progLocalParamNum .and rbracket .emit 0x00;

/*
    <progEnvParamNum>      ::= <integer> from 0 to
                               MAX_PROGRAM_ENV_PARAMETERS_ARB - 1
*/
progEnvParamNum
    integer;

/*
    <progLocalParamNum>    ::= <integer> from 0 to
                               MAX_PROGRAM_LOCAL_PARAMETERS_ARB - 1
*/
progLocalParamNum
    integer;

/*
    <paramConstDecl>       ::= <paramConstScalarDecl>
                             | <paramConstVector>
*/
paramConstDecl
    paramConstScalarDecl .emit CONSTANT_SCALAR .or paramConstVector .emit CONSTANT_VECTOR;

/*
    <paramConstUse>        ::= <paramConstScalarUse>
                             | <paramConstVector>
*/
paramConstUse
    paramConstScalarUse .emit CONSTANT_SCALAR .or paramConstVector .emit CONSTANT_VECTOR;

/*
    <paramConstScalarDecl> ::= <signedFloatConstant>
*/
paramConstScalarDecl
    signedFloatConstant;

/*
    <paramConstScalarUse>  ::= <floatConstant>
*/
paramConstScalarUse
    floatConstant;

/*
    <paramConstVector>     ::= "{" <signedFloatConstant> "}"
                             | "{" <signedFloatConstant> "," 
                                   <signedFloatConstant> "}"
                             | "{" <signedFloatConstant> "," 
                                   <signedFloatConstant> ","
                                   <signedFloatConstant> "}"
                             | "{" <signedFloatConstant> "," 
                                   <signedFloatConstant> ","
                                   <signedFloatConstant> "," 
                                   <signedFloatConstant> "}"
*/
paramConstVector
    paramConstVector_4 .emit 0x04 .or paramConstVector_3 .emit 0x03 .or
    paramConstVector_2 .emit 0x02 .or paramConstVector_1 .emit 0x01;
paramConstVector_1
    lbrace_ne .and signedFloatConstant .and rbrace;
paramConstVector_2
    lbrace_ne .and signedFloatConstant .and comma_ne .and signedFloatConstant .and rbrace;
paramConstVector_3
    lbrace_ne .and signedFloatConstant .and comma_ne .and signedFloatConstant .and comma_ne .and
    signedFloatConstant .and rbrace;
paramConstVector_4
    lbrace_ne .and signedFloatConstant .and comma_ne .and signedFloatConstant .and comma_ne .and
    signedFloatConstant .and comma_ne .and signedFloatConstant .and rbrace;

/*
    <signedFloatConstant>  ::= <optionalSign> <floatConstant>
*/
signedFloatConstant
    optionalSign .and floatConstant;

/*
    <floatConstant>        ::= see text
    The <floatConstant> rule matches a floating-point constant consisting
    of an integer part, a decimal point, a fraction part, an "e" or
    "E", and an optionally signed integer exponent.  The integer and
    fraction parts both consist of a sequence of one or more digits ("0"
    through "9").  Either the integer part or the fraction parts (not
    both) may be missing; either the decimal point or the "e" (or "E")
    and the exponent (not both) may be missing.
*/
floatConstant
    float;

/*
    <optionalSign>         ::= ""
                             | "-"
                             | "+"
*/
optionalSign
    optional_sign_ne;

/*
    <TEMP_statement>       ::= "TEMP" <varNameList>
*/
fp_TEMP_statement
    "TEMP" .and space .and fp_varNameList .and .true .emit 0x00;
vp_TEMP_statement
    "TEMP" .and space .and vp_varNameList .and .true .emit 0x00;

/*
vertex program
    <ADDRESS_statement>    ::= "ADDRESS" <varNameList>
*/
ADDRESS_statement
    "ADDRESS" .and space .and vp_varNameList .and .true .emit 0x00;

/*
    <varNameList>          ::= <establishName>
                             | <establishName> "," <varNameList>
*/
fp_varNameList
    fp_varNameList_1 .or fp_establishName;
vp_varNameList
    vp_varNameList_1 .or vp_establishName;
fp_varNameList_1
    fp_establishName .and comma_ne .and fp_varNameList;
vp_varNameList_1
    vp_establishName .and comma_ne .and vp_varNameList;

/*
    <OUTPUT_statement>     ::= "OUTPUT" <establishName> "="
                                 <resultBinding>
*/
fp_OUTPUT_statement
    "OUTPUT" .and space .and fp_establishName .and equal .and
    fp_resultBinding .error RESULT_EXPECTED;
vp_OUTPUT_statement
    "OUTPUT" .and space .and vp_establishName .and equal .and
    vp_resultBinding .error RESULT_EXPECTED;

/*
fragment program
    <resultBinding>        ::= "result" "." "color"
                             | "result" "." "color" <optOutputColorNum> (if option ARB_draw_buffers present)
                             | "result" "." "depth"

vertex program
    <resultBinding>        ::= "result" "." "position"
                             | "result" "." <resultColBinding>
                             | "result" "." "fogcoord"
                             | "result" "." "pointsize"
                             | "result" "." "texcoord" <optTexCoordNum>
*/
fp_resultBinding
    "result" .and dot .and fp_resultBinding_1 .error INVALID_RESULT_PROPERTY;
vp_resultBinding
    "result" .and dot .and vp_resultBinding_1 .error INVALID_RESULT_PROPERTY;
fp_resultBinding_1
    fp_resultBinding_2 .emit FRAGMENT_RESULT_COLOR .or
    "depth" .emit FRAGMENT_RESULT_DEPTH;
fp_resultBinding_2
    "color" .and optOutputColorNum;
vp_resultBinding_1
    .if (ARB_position_invariant == 0x00) "position" .emit VERTEX_RESULT_POSITION .or
    resultColBinding .emit VERTEX_RESULT_COLOR .or
    "fogcoord" .emit VERTEX_RESULT_FOGCOORD .or
    "pointsize" .emit VERTEX_RESULT_POINTSIZE .or
    vp_resultBinding_2 .emit VERTEX_RESULT_TEXCOORD;
vp_resultBinding_2
    "texcoord" .and optTexCoordNum;

/*
GL_ARB_draw_buffers
    <optOutputColorNum>    ::= ""
                             | "[" <outputColorNum> "]"
*/
optOutputColorNum
    .if (ARB_draw_buffers != 0x00) optOutputColorNum_1 .or .true .emit 0x00;
optOutputColorNum_1
    lbracket_ne .and outputColorNum .and rbracket;

/*
GL_ARB_draw_buffers
    <outputColorNum>       ::= <integer> from 0 to MAX_DRAW_BUFFERS_ARB-1
*/
outputColorNum
    integer;

/*
vertex program
    <resultColBinding>     ::= "color" <optFaceType> <optColorType>
*/
resultColBinding
    "color" .and optFaceType .and optColorType;

/*
    <optFaceType>          ::= ""
                             | "." "front"
                             | "." "back"
*/
optFaceType
    FaceType .or .true .emit FACE_FRONT;
FaceType
    dot_ne .and FaceProperty;
FaceProperty
    "front" .emit FACE_FRONT .or "back" .emit FACE_BACK;

/*
    <optColorType>         ::= ""
                             | "." "primary"
                             | "." "secondary"
*/
optColorType
    ColorType .or .true .emit COLOR_PRIMARY;
ColorType
    dot_ne .and ColorProperty;
ColorProperty
    "primary" .emit COLOR_PRIMARY .or
    .if (secondary_color != 0x00) "secondary" .emit COLOR_SECONDARY;

/*
    <ALIAS_statement>      ::= "ALIAS" <establishName> "="
                                 <establishedName>
*/
fp_ALIAS_statement
    "ALIAS" .and fp_ALIAS_statement_1 .error IDENTIFIER_EXPECTED .and equal .and fp_establishedName;
vp_ALIAS_statement
    "ALIAS" .and vp_ALIAS_statement_1 .error IDENTIFIER_EXPECTED .and equal .and vp_establishedName;
fp_ALIAS_statement_1
    space .and fp_establishName;
vp_ALIAS_statement_1
    space .and vp_establishName;

/*
    <establishName>        ::= <identifier>
*/
fp_establishName
    fp_identifier;
vp_establishName
    vp_identifier;

/*
    <establishedName>      ::= <identifier>
*/
fp_establishedName
    fp_identifier;
vp_establishedName
    vp_identifier;
fp_establishedName_no_error_on_identifier
    fp_identifier_ne;
vp_establishedName_no_error_on_identifier
    vp_identifier_ne;

/*
fragment program
    <identifier>           ::= see text
    The <identifier> rule matches a sequence of one or more letters ("A"
    through "Z", "a" through "z"), digits ("0" through "9), underscores 
    ("_"), or dollar signs ("$"); the first character must not be a 
    number.  Upper and lower case letters are considered different 
    (names are case-sensitive).  The following strings are reserved 
    keywords and may not be used as identifiers:

        ABS, ABS_SAT, ADD, ADD_SAT, ALIAS, ATTRIB, CMP, CMP_SAT, COS,
        COS_SAT, DP3, DP3_SAT, DP4, DP4_SAT, DPH, DPH_SAT, DST, DST_SAT, 
        END, EX2, EX2_SAT, FLR, FLR_SAT, FRC, FRC_SAT, KIL, LG2, 
        LG2_SAT, LIT, LIT_SAT, LRP, LRP_SAT, MAD, MAD_SAT, MAX, MAX_SAT, 
        MIN, MIN_SAT, MOV, MOV_SAT, MUL, MUL_SAT, OPTION, OUTPUT, PARAM, 
        POW, POW_SAT, RCP, RCP_SAT, RSQ, RSQ_SAT, SIN, SIN_SAT, SCS, 
        SCS_SAT, SGE, SGE_SAT, SLT, SLT_SAT, SUB, SUB_SAT, SWZ, SWZ_SAT, 
        TEMP, TEX, TEX_SAT, TXB, TXB_SAT, TXP, TXP_SAT, XPD, XPD_SAT, 
        fragment, program, result, state, and texture.

vertex program
    <identifier>           ::= see text
    The <identifier> rule matches a sequence of one or more letters ("A"
    through "Z", "a" through "z"), digits ("0" through "9), underscores ("_"),
    or dollar signs ("$"); the first character must not be a number.  Upper
    and lower case letters are considered different (names are
    case-sensitive).  The following strings are reserved keywords and may not
    be used as identifiers:

        ABS, ADD, ADDRESS, ALIAS, ARL, ATTRIB, DP3, DP4, DPH, DST, END, EX2,
        EXP, FLR, FRC, LG2, LIT, LOG, MAD, MAX, MIN, MOV, MUL, OPTION, OUTPUT,
        PARAM, POW, RCP, RSQ, SGE, SLT, SUB, SWZ, TEMP, XPD, program, result,
        state, and vertex.
*/
fp_identifier
    fp_identifier_ne .error IDENTIFIER_EXPECTED;
vp_identifier
    vp_identifier_ne .error IDENTIFIER_EXPECTED;
fp_identifier_ne
    fp_not_reserved_identifier .and identifier_ne;
vp_identifier_ne
    vp_not_reserved_identifier .and identifier_ne;

fp_not_reserved_identifier
    fp_not_reserved_identifier_1 .or .true;
fp_not_reserved_identifier_1
    fp_reserved_identifier .and .false .error RESERVED_KEYWORD;
vp_not_reserved_identifier
    vp_not_reserved_identifier_1 .or .true;
vp_not_reserved_identifier_1
    vp_reserved_identifier .and .false .error RESERVED_KEYWORD;

fp_reserved_identifier
    "ABS" .or "ABS_SAT" .or "ADD" .or "ADD_SAT" .or "ALIAS" .or "ATTRIB" .or "CMP" .or "CMP_SAT" .or
    "COS" .or "COS_SAT" .or "DP3" .or "DP3_SAT" .or "DP4" .or "DP4_SAT" .or "DPH" .or "DPH_SAT" .or
    "DST" .or "DST_SAT" .or "END" .or "EX2" .or "EX2_SAT" .or "FLR" .or "FLR_SAT" .or "FRC" .or
    "FRC_SAT" .or "KIL" .or "LG2" .or "LG2_SAT" .or "LIT" .or "LIT_SAT" .or "LRP" .or "LRP_SAT" .or
    "MAD" .or "MAD_SAT" .or "MAX" .or "MAX_SAT" .or "MIN" .or "MIN_SAT" .or "MOV" .or "MOV_SAT" .or
    "MUL" .or "MUL_SAT" .or "OPTION" .or "OUTPUT" .or "PARAM" .or "POW" .or "POW_SAT" .or "RCP" .or
    "RCP_SAT" .or "RSQ" .or "RSQ_SAT" .or "SIN" .or "SIN_SAT" .or "SCS" .or "SCS_SAT" .or "SGE" .or
    "SGE_SAT" .or "SLT" .or "SLT_SAT" .or "SUB" .or "SUB_SAT" .or "SWZ" .or "SWZ_SAT" .or "TEMP" .or
    "TEX" .or "TEX_SAT" .or "TXB" .or "TXB_SAT" .or "TXP" .or "TXP_SAT" .or "XPD" .or "XPD_SAT" .or
    "fragment" .or "program" .or "result" .or "state" .or "texture";
vp_reserved_identifier
    "ABS" .or "ADD" .or "ADDRESS" .or "ALIAS" .or "ARL" .or "ATTRIB" .or "DP3" .or "DP4" .or
    "DPH" .or "DST" .or "END" .or "EX2" .or "EXP" .or "FLR" .or "FRC" .or "LG2" .or "LIT" .or
    "LOG" .or "MAD" .or "MAX" .or "MIN" .or "MOV" .or "MUL" .or "OPTION" .or "OUTPUT" .or
    "PARAM" .or "POW" .or "RCP" .or "RSQ" .or "SGE" .or "SLT" .or "SUB" .or "SWZ" .or "TEMP" .or
    "XPD" .or "program" .or "result" .or "state" .or "vertex";

/*
    The <integer> rule matches an integer constant.  The integer consists
    of a sequence of one or more digits ("0" through "9").
*/
integer
    integer_ne .error INTEGER_EXPECTED;

zero
    '0';

leading_zeroes
    .loop zero;

no_digit
    no_digit_1 .or .true;
no_digit_1
    digit10 .and .false .error INTEGER_OUT_OF_RANGE;

all_zeroes
    all_zeroes_1 .or no_digit_1;
all_zeroes_1
    '0' .and .loop zero .and no_digit;

integer_0_3
    integer_0_3_1 .error INTEGER_EXPECTED .and .true .emit 0x00 .emit $;
integer_0_3_1
    integer_0_3_2 .or all_zeroes .emit '0';
integer_0_3_2       /* [1, 3] */
    leading_zeroes .and '1'-'3' .emit * .and no_digit;

integer_0_63
    integer_0_63_1 .error INTEGER_EXPECTED .and .true .emit 0x00 .emit $;
integer_0_63_1
    integer_0_63_2 .or integer_0_63_3 .or integer_0_63_4 .or integer_0_63_5 .or
    all_zeroes .emit '0';
integer_0_63_2      /* [7, 9] */
    leading_zeroes .and '7'-'9' .emit * .and no_digit;
integer_0_63_3      /* [10, 59] */
    leading_zeroes .and '1'-'5' .emit * .and '0'-'9' .emit * .and no_digit;
integer_0_63_4      /* [60, 63] */
    leading_zeroes .and '6' .emit * .and '0'-'3' .emit * .and no_digit;
integer_0_63_5      /* [1, 6] */
    leading_zeroes .and '1'-'6' .emit * .and no_digit;

integer_0_64
    integer_0_64_1 .error INTEGER_EXPECTED .and .true .emit 0x00 .emit $;
integer_0_64_1
    integer_0_64_2 .or integer_0_64_3 .or integer_0_64_4 .or integer_0_64_5 .or
    all_zeroes .emit '0';
integer_0_64_2      /* [7, 9] */
    leading_zeroes .and '7'-'9' .emit * .and no_digit;
integer_0_64_3      /* [10, 59] */
    leading_zeroes .and '1'-'5' .emit * .and '0'-'9' .emit * .and no_digit;
integer_0_64_4      /* [60, 64] */
    leading_zeroes .and '6' .emit * .and '0'-'4' .emit * .and no_digit;
integer_0_64_5      /* [1, 6] */
    leading_zeroes .and '1'-'6' .emit * .and no_digit;

optional_space
    space .or .true;

space_dst
    space .error OPERATION_NEEDS_DESTINATION_VARIABLE;

space_src
    space .error OPERATION_NEEDS_SOURCE_VARIABLE;

space
    single_space .and .loop single_space;

single_space
    white_char .or comment_block;

white_char
    ' ' .or '\t' .or '\n' .or '\r';

comment_block
    '#' .and .loop comment_char .and new_line;

/* All ASCII characters except '\r', '\n' and '\0' */
comment_char
    '\x0E'-'\xFF' .or '\x01'-'\x09' .or '\x0B'-'\x0C';

new_line
    '\n' .or crlf .or '\0';

crlf
    '\r' .and '\n';

semicolon
    optional_space .and ';' .error MISSING_SEMICOLON .and optional_space;

comma
    optional_space .and ',' .error MISSING_COMMA .and optional_space;

comma_ne
    optional_space .and ',' .and optional_space;

lbracket
    optional_space .and '[' .error MISSING_LBRACKET .and optional_space;

lbracket_ne
    optional_space .and '[' .and optional_space;

rbracket
    optional_space .and ']' .error MISSING_RBRACKET .and optional_space;

dot
    optional_space .and '.' .error MISSING_DOT .and optional_space;

dot_ne
    optional_space .and '.' .and optional_space;

equal
    optional_space .and '=' .error MISSING_EQUAL .and optional_space;

lbrace
    optional_space .and '{' .error MISSING_LBRACE .and optional_space;

lbrace_ne
    optional_space .and '{' .and optional_space;

rbrace
    optional_space .and '}' .error MISSING_RBRACE .and optional_space;

dotdot
    optional_space .and '.' .and '.' .error MISSING_DOTDOT .and optional_space;

dotdot_ne
    optional_space .and '.' .and '.' .and optional_space;

/*
    The definition below accepts the following floating point number formats:
    .99 .99e99 99. 99.99 99.99e99 99.e99 99e99
    Also 99 format was considered and accepted because of a large number of existing program
    strings with such a format.
*/
float
    float_1 .or float_2 .or float_legacy;
float_1
    '.' .emit 0x00 .and integer_ne .error MISSING_FRACTION_OR_EXPONENT .and optional_exponent;
float_2
    integer_ne .and float_3;
float_3
    float_4 .or float_5;
float_4
    '.' .and optional_integer .and optional_exponent;
float_5
    exponent .emit 0x00;
float_legacy
    integer_ne .and .true .emit 0x00 .emit 0x00;

/*
    Below is a correct version of <float> definiton.
*/
/*
float
    float_1 .or float_2;
float_1
    '.' .emit 0x00 .and integer_ne .error MISSING_FRACTION_OR_EXPONENT .and optional_exponent;
float_2
    integer_ne .and float_3 .error MISSING_DOT_OR_EXPONENT;
float_3
    float_4 .or float_5;
float_4
    '.' .and optional_integer .and optional_exponent;
float_5
    exponent .emit 0x00;
*/

integer_ne
    integer_ne_1 .and .true .emit 0x00 .emit $;
integer_ne_1
    digit10 .emit * .and .loop digit10 .emit *;

optional_integer
    integer_ne .or .true .emit 0x00;

/*
NOTE: If exponent part is omited we treat it as if it was "E+1".
*/
optional_exponent
    exponent .or .true .emit 0x00;

exponent
    exponent_1 .and optional_sign_ne .and integer_ne .error EXPONENT_VALUE_EXPECTED;
exponent_1
    'e' .or 'E';

optional_sign_ne
    minus_ne .or plus_ne .or .true;

plus_ne
    optional_space .and '+' .and optional_space;

minus_ne
    optional_space .and '-' .emit '-' .and optional_space;

identifier_ne
    first_idchar .emit * .and .loop follow_idchar .emit * .and .true .emit 0x00 .emit $;

follow_idchar
    first_idchar .or digit10;

first_idchar
    'a'-'z' .or 'A'-'Z' .or '_' .or '$';

digit10
    '0'-'9';

/*
    string filtering - if a string is encountered in grammar ("blabla"), the symbol below is
    executed to create the string. The symbol must not throw any errors and emit bytes - it should
    stop if it encounters invalid character. After this the resulting string (from starting
    position up to the invalid character (but without it) is compared with the grammar string.
*/
.string __string_filter;

__string_filter
    .loop __identifier_char;

__identifier_char
    'a'-'z' .or 'A'-'Z' .or '_' .or '$' .or '0'-'9';

/*
    error token filtering
*/
e_signature
    e_signature_char .and .loop e_signature_char;
e_signature_char
    '!' .or '.' .or 'A'-'Z' .or 'a'-'z' .or '0'-'9';

e_statement
    .loop e_statement_not_term;
/* All ASCII characters to one of '\r', '\n', '\0' and ';' */
e_statement_not_term
    '\x3C'-'\xFF' .or '\x0E'-'\x3A' .or '\x01'-'\x09' .or '\x0B'-'\x0C';

e_identifier
    e_identifier_first .and .loop e_identifier_next;
e_identifier_first
    'a'-'z' .or 'A'-'Z' .or '_' .or '$';
e_identifier_next
    e_identifier_first .or '0'-'9';

e_token
    e_identifier .or e_token_number .or '[' .or ']' .or '.' .or '{' .or '}' .or '=' .or '+' .or
    '-' .or ',' .or ';';
e_token_number
    e_token_digit .and .loop e_token_digit;
e_token_digit
    '0'-'9';

e_charordigit
    'A'-'Z' .or 'a'-'z' .or '0'-'9';

